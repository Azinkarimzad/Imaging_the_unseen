<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en" data-bs-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Imaging the underworld_GPR edition: All in One View</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="assets/themetoggle.js"></script><link rel="stylesheet" type="text/css" href="assets/styles.css">
<script src="assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="favicons/incubator/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicons/incubator/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicons/incubator/favicon-16x16.png">
<link rel="manifest" href="favicons/incubator/site.webmanifest">
<link rel="mask-icon" href="favicons/incubator/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="white">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black">
</head>
<body>
    <header id="top" class="navbar navbar-expand-md top-nav incubator"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewbox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></symbol><symbol id="circle-half" viewbox="0 0 16 16"><path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path></symbol><symbol id="moon-stars-fill" viewbox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></symbol><symbol id="sun-fill" viewbox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></symbol></svg><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-8">
      <div class="large-logo">
        <img id="incubator-logo" alt="Lesson Description mm" src="assets/images/incubator-logo.svg"><span class="badge text-bg-danger">
          <abbr title="This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.">
            <a href="https://docs.carpentries.org/resources/curriculum/lesson-life-cycle.html" class="external-link alert-link">
              <i aria-hidden="true" class="icon" data-feather="alert-octagon" style="border-radius: 5px"></i>
              Pre-Alpha
            </a>
            <span class="visually-hidden">This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.</span>
          </abbr>
        </span>

      </div>
    </div>
    <div class="selector-container">
      <div id="theme-selector">
        <li class="nav-item dropdown" id="theme-button-list">
          <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
            <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
<li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                Light
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                Dark
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                Auto
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
          </ul>
</li>
      </div>

      <div class="dropdown" id="instructor-dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Learner View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
<li><button class="dropdown-item" type="button" onclick="window.location.href='instructor/aio.html';">Instructor View</button></li>
        </ul>
</div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="Lesson Description mm" src="assets/images/incubator-logo-sm.svg">
</div>
    <div class="lesson-title-md">
      Imaging the underworld_GPR edition
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
          <span class="lesson-title">
            Imaging the underworld_GPR edition
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="reference.html#glossary">Glossary</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="profiles.html">Learner Profiles</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
          </ul>
</li>
      </ul>
</div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a id="search-button" class="btn btn-primary" href="aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div>
<!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  Imaging the underworld_GPR edition
</div>

<aside class="col-md-12 lesson-progress"><div style="width: %" class="percentage">
    %
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: %" aria-valuenow="" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row" id="theme-row-mobile">
            <div class="col" id="theme-selector">
              <li class="nav-item dropdown" id="theme-button-list">
                <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
                  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><span class="d-lg-none ms-1" id="bd-theme-text">Toggle Theme</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="bd-theme-text">
<li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                      Light
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                      Dark
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                      <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                      Auto
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                </ul>
</li>
            </div>
          </div>
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Learner View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="instructor/aio.html">Instructor View</a>
                      </div>
                    </div>
                  </div>
<!--/div.accordion-item-->
                </div>
<!--/div.accordion-flush-->
              </div>
<!--div.sidenav-view-selector -->
            </div>
<!--/div.col -->

            <hr>
</div>
<!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Setup</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="introduction.html">1. introduction</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="Intro%20and%20Theory%20Refresher.html">2. Intro and Theory Refresher</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="AGC%20Implementation.html">3. AGC</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="Background%20Removal.html">4. Background Removal</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="Time-Zero%20Correction.html">5. Time-Zero Correction</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="Bandpass%20Filtering.html">6. Bandpass Filtering</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="Deconvolution.html">7. Deconvolution</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="Wrap-up%20and%20Discussion.html">8. Wrap-up and Discussion</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width">
<div class="accordion accordion-flush lesson-resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="lesson-resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul>
<li>
                        <a href="key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="reference.html#glossary">Glossary</a>
                      </li>
                      <li>
                        <a href="profiles.html">Learner Profiles</a>
                      </li>
                      <li><a href="reference.html">Reference</a></li>
                    </ul>
</div>
                </div>
              </div>
            </div>
            <hr class="half-width lesson-resources">
<a href="aio.html">See all in one page</a>


            <hr class="d-none d-sm-block d-md-none">
<div class="d-grid gap-1">

            </div>
          </div>
<!-- /div.accordion -->
        </div>
<!-- /div.sidebar-inner -->
      </nav>
</div>
<!-- /div.sidebar -->
  </div>
<!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-extra.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <main id="main-content" class="main-content"><div class="container lesson-content">
        
        
<section id="aio-introduction"><p>Content from <a href="introduction.html">introduction</a></p>
<hr>
<p>Last updated on 2025-04-14 |

        <a href="https://github.com/Azinkarimzad/Imaging_the_unseen/edit/main/episodes/introduction.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How do you write a lesson using Markdown and
<a href="https://carpentries.github.io/sandpaper/" class="external-link">sandpaper</a>?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Explain how to use markdown with The Carpentries Workbench</li>
<li>Demonstrate how to include pieces of code, figures, and nested
challenge blocks</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>This is a lesson created via The Carpentries Workbench. It is written
in <a href="https://pandoc.org/MANUAL.html" class="external-link">Pandoc-flavored Markdown</a>
for static files and <a href="https://rmarkdown.rstudio.com/" class="external-link">R
Markdown</a> for dynamic files that can render code into output. Please
refer to the <a href="https://carpentries.github.io/sandpaper-docs/" class="external-link">Introduction to The
Carpentries Workbench</a> for full documentation.</p>
<p>What you need to know is that there are three sections required for a
valid Carpentries lesson:</p>
<ol style="list-style-type: decimal">
<li>
<code>questions</code> are displayed at the beginning of the episode
to prime the learner for the content.</li>
<li>
<code>objectives</code> are the learning objectives for an episode
displayed with the questions.</li>
<li>
<code>keypoints</code> are displayed at the end of the episode to
reinforce the objectives.</li>
</ol>
<div id="challenge-1-can-you-do-it" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="challenge-1-can-you-do-it" class="callout-inner">
<h3 class="callout-title">Challenge 1: Can you do it?</h3>
<div class="callout-content">
<p>What is the output of this command?</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">paste</span><span class="op">(</span><span class="st">"This"</span>, <span class="st">"new"</span>, <span class="st">"lesson"</span>, <span class="st">"looks"</span>, <span class="st">"good"</span><span class="op">)</span></span></code></pre>
</div>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Output </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[1] "This new lesson looks good"</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="challenge-2-how-do-you-nest-solutions-within-challenge-blocks" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="challenge-2-how-do-you-nest-solutions-within-challenge-blocks" class="callout-inner">
<h3 class="callout-title">Challenge 2: how do you nest solutions within
challenge blocks?</h3>
<div class="callout-content">

</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>You can add a line with at least three colons and a
<code>solution</code> tag.</p>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="figures">Figures<a class="anchor" aria-label="anchor" href="#figures"></a>
</h2>
<hr class="half-width">
<p>You can use standard markdown for static figures with the following
syntax:</p>
<p><code>![optional caption that appears below the figure](figure url){alt='alt text for accessibility purposes'}</code></p>
<figure><img src="https://raw.githubusercontent.com/carpentries/logo/master/Badge_Carpentries.svg" alt="Blue Carpentries hex person logo with no text." class="figure mx-auto d-block"><div class="figcaption">You belong in The Carpentries!</div>
</figure><div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div class="callout-inner">
<div class="callout-content">
<p>Callout sections can highlight information.</p>
<p>They are sometimes used to emphasise particularly important points
but are also used in some lessons to present “asides”: content that is
not central to the narrative of the lesson, e.g. by providing the answer
to a commonly-asked question.</p>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="math">Math<a class="anchor" aria-label="anchor" href="#math"></a>
</h2>
<hr class="half-width">
<p>One of our episodes contains <span class="math inline">\(\LaTeX\)</span> equations when describing how to
create dynamic reports with {knitr}, so we now use mathjax to describe
this:</p>
<p><code>$\alpha = \dfrac{1}{(1 - \beta)^2}$</code> becomes: <span class="math inline">\(\alpha = \dfrac{1}{(1 - \beta)^2}\)</span></p>
<p>Cool, right?</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>Use <code>.md</code> files for episodes when you want static
content</li>
<li>Use <code>.Rmd</code> files for episodes when you need to generate
output</li>
<li>Run <code>sandpaper::check_lesson()</code> to identify any issues
with your lesson</li>
<li>Run <code>sandpaper::build_lesson()</code> to preview your lesson
locally</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-Intro and Theory Refresher"><p>Content from <a href="Intro%20and%20Theory%20Refresher.html">Intro and Theory Refresher</a></p>
<hr>
<p>Last updated on 2025-09-07 |

        <a href="https://github.com/Azinkarimzad/Imaging_the_unseen/edit/main/episodes/Intro%20and%20Theory%20Refresher.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li><p>What are the core components of a GPR system?</p></li>
<li><p>How does GPR work to detect subsurface changes?</p></li>
<li><p>What does a GPR trace represent?</p></li>
<li><p>How can we process and visualize SEG-Y GPR data using
Python?</p></li>
<li><p>What are the core hardware and data-logging components of a GPR
system, and how do they interact during acquisition?</p></li>
<li><p>Through which physical contrasts does GPR detect subsurface
changes, and how do antenna frequency and bandwidth control resolution
and depth?</p></li>
<li><p>What does a single GPR trace represent in time and in depth, and
how is a radargram constructed from adjacent traces?</p></li>
<li><p>How can we read, inspect metadata, and visualize SEG-Y GPR data
in Python using ObsPy without modifying the raw samples?</p></li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li><p>Understand the structure and functionality of a GPR
system.</p></li>
<li><p>Explain the concept of GPR signal reflection and trace
acquisition.</p></li>
<li><p>Interpret what a single GPR trace and a 2D radargram
represent.</p></li>
<li><p>Demonstrate loading and visualizing GPR SEG-Y data using Python
and obspy.</p></li>
<li><p>Identify the console, antenna, and encoder roles in a modern GPR
system and relate them to sampling, time window, and spatial
sampling.</p></li>
<li><p>Explain reflection generation from dielectric permittivity
contrasts and the implications for amplitude, polarity, and travel
time.</p></li>
<li><p>Interpret a trace as a one-dimensional time series and a
radargram as a two-dimensional section built by lateral stacking of
traces.</p></li>
<li><p>Demonstrate loading SEG-Y, inspecting basic headers, and plotting
trace-level and section-level views using ObsPy and matplotlib.</p></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>GPR uses EM waves to detect subsurface features.</li>
<li>A trace is a time series of reflections from a point.</li>
<li>SEG-Y files can be visualized using ObsPy.</li>
<li>GPR emits broadband electromagnetic pulses; reflections arise at
contrasts in relative permittivity, conductivity, or magnetic
permeability.</li>
<li>A GPR trace is amplitude versus two-way travel time at a single
surface position; a radargram is a collection of traces along a
profile.</li>
<li>SEG-Y is a common container for GPR; ObsPy can read variable-length
traces and expose headers needed for plotting and basic QC.</li>
<li>Antenna frequency controls depth–resolution trade-off: lower
frequency penetrates deeper with coarser resolution; higher frequency
resolves finer targets at shallower depths.</li>
</ul>
</div>
</div>
</div>
<div class="introduction">
<div class="section level2">
<h2 id="what-is-geophysics">What is geophysics?<a class="anchor" aria-label="anchor" href="#what-is-geophysics"></a>
</h2>
<p>In the broadest sense, the science of geophysics is the application
of physics to investigations of the Earth, Moon and planets. The subject
is thus related to astronomy. To avoid confusion, the use of physics to
study the interior of the Earth, from land surface to the inner core, is
known as solid earth geophysics. Applied geophysics’ covers everything
from experiments to determine the thickness of the crust (which is
important in hydrocarbon exploration) to studies of shallow structures
for engineering site investigations, exploring for groundwater and for
minerals and other economic resources, to trying to locate narrow mine
shafts or other forms of buried cavities, or the mapping of
archaeological remains, or locating buried pipes and cables – but where
in general the total depth of investigation is usually less than 100
m.</p>
<p>Ground penetrating radar (GPR) is now a well-accepted geophysical
technique. The method uses radio waves to probe “the ground”. In its
earliest inception, GPR was primarily applied to natural geologic
materials. Now GPR is equally well applied to a host of other media such
as wood, concrete, and asphalt. The most common form of GPR measurements
deploys a transmitter and a receiver in a fixed geometry, which are
moved over the surface to detect reflections from subsurface features.
Ground penetrating radar systems are conceptually simple; the objective
is to measure field amplitude versus time after excitation. The heart of
a GPR system is the timing unit, which controls the generation and
detection of signals. Most GPRs operate in the time domain. GPRs are
normally characterized by their center frequency. The common range
varies between 50MHz to 2.5 GHz.</p>
<p>Most GPR consist of three components: a console, an antenna, and an
encoder. The first two are mandatory. The third is typical for 99
percent of GPR users that work in the utility locating, civil
engineering, concrete scanning, and archaeology industries. The console
is the brains of the system. This data logger communicates with both the
encoder and the antenna to initiate a signal and record the responses.
The antenna is where the GPR signal is produced. The encoder, also
referred to as a survey wheel, controls for locational accuracy of the
GPR data. As the wheel turns a fraction of a turn, the console will
initialize the antenna. Most GPR antenna actually consist of a
transmitter and a receiver, and once it is initialized by the console,
the transmitter will produce the signal. The receiver will record
responses for a defined amount of time and once that “time window” has
reached its maximum time, the console will terminate the receiver from
recording any more data.</p>
<p>The GPR antenna produces an electromagnetic pulse at the ground
surface. This pulse, which is in the form of a wave, travels into the
subsurface and will continue until one of two things happen: the signal
strength totally decays, or the wave encounters a change in the physical
properties of the subsurface material. This change can be a small target
such as a buried pipe or a large geological layer such a bedrock. When
the wave encounters a change in material properties, some of the wave’s
energy will reflect back to the ground surface and some will transmit
further into the ground if any energy is left. This produces a
one-dimensional view just below the antenna. If multiple of these
one-dimensional views are collected next to each other (i.e. the GPR is
pushed along the ground surface in a line), then a twodimensional view
of the subsurface will be generated by the GPR. This two-dimensional
view is equivalent to looking at the wall of an excavation trench. It is
a vertical profile of the subsurface directly beneath the path that the
GPR was pushed.</p>
<figure><img src="%7B%7B%20site.baseurl%20%7D%7D/site/GPR-method-3.1.jpg" alt="Diagram of a GPR system showing console, antenna, and encoder." class="figure mx-auto d-block"><div class="figcaption">Schematic of a GPR setup</div>
</figure><p>In this episode we will read and visualize a GPR trace from SEG-Y
data using Python and the ObsPy library. The aim is rapid inspection for
quality control and for building intuition on trace and section
appearance prior to any processing.</p>
<p>Example data context</p>
<p>Assume LINE01.sgy is a single profile recorded with an air-coupled or
ground-coupled system. The file may contain variable-length traces. The
sampling interval, number of samples, and textual or binary headers
carry acquisition metadata.</p>
<p>Example 1: Plot a single trace</p>
<p>Example 2: Build a radargram</p>
<p>Example 3: Inspect metadata</p>
<p>Example 4: Add a time axis</p>
<p>Example 5: Apply a gain</p>
</div>
<div class="section level2">
<h2 id="example-1-plot-a-single-trace-for-a-quick-look">Example 1 — Plot a single trace for a quick look<a class="anchor" aria-label="anchor" href="#example-1-plot-a-single-trace-for-a-quick-look"></a>
</h2>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">from</span> obspy.io.segy.segy <span class="im">import</span> _read_segy</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co"># Load SEG-Y using ObsPy (handles variable-length traces)</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>stream <span class="op">=</span> _read_segy(<span class="st">"LINE01.sgy"</span>, headonly<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="co"># Access trace data</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>trace0 <span class="op">=</span> stream.traces[<span class="dv">0</span>].data</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>n_traces <span class="op">=</span> <span class="bu">len</span>(stream.traces)</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="co"># Plot first trace</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>plt.plot(trace0)</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>plt.title(<span class="st">"First Trace from LINE01.sgy"</span>)</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>plt.xlabel(<span class="st">"Sample Index"</span>)</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>plt.ylabel(<span class="st">"Amplitude"</span>)</span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>What this code does, step by step:</p>
<p>Import readers and plotting: brings in ObsPy’s private SEG-Y reader
and matplotlib.</p>
<p>Read the SEG-Y stream: _read_segy parses the file into a
SEGYFile-like object with a .traces list. headonly=False ensures sample
arrays are read, not just headers.</p>
<p>Select the first trace: stream.traces[0].data returns a
one-dimensional array of amplitudes for the first position along the
line.</p>
<p>Count traces: len(stream.traces) gives the number of positions
acquired.</p>
<p>Plot the raw samples: the x-axis is sample index, not time, because a
sample interval has not been applied; the y-axis is recorded amplitude
in instrument units.</p>
<p>Interpretation note: a clear early-time direct wave or ring-down may
dominate the first part of the trace; deeper reflections appear later in
the sample index.</p>
<p>Add-on checks on performance:</p>
<p>Confirm whether amplitudes are signed and whether clipping is
visible.</p>
<p>convert sample index to time using the trace header sample
interval.</p>
<p>Look for saturation or DC drift that might require dewow in further
processing.</p>
</div>
<div class="section level2">
<h2 id="example-2-build-a-simple-radargram-image-from-all-traces">Example 2 — Build a simple radargram image from all traces<a class="anchor" aria-label="anchor" href="#example-2-build-a-simple-radargram-image-from-all-traces"></a>
</h2>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="im">from</span> obspy.io.segy.segy <span class="im">import</span> _read_segy</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="co"># Load SEG-Y file</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>segy_file <span class="op">=</span> <span class="st">"LINE01.sgy"</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>stream <span class="op">=</span> _read_segy(segy_file, headonly<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="co"># Number of traces and max trace length</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>n_traces <span class="op">=</span> <span class="bu">len</span>(stream.traces)</span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>max_len <span class="op">=</span> <span class="bu">max</span>(<span class="bu">len</span>(tr.data) <span class="cf">for</span> tr <span class="kw">in</span> stream.traces)</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a><span class="co"># Fill 2D array with seismic data</span></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a>data <span class="op">=</span> np.zeros((max_len, n_traces))</span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a><span class="cf">for</span> i, tr <span class="kw">in</span> <span class="bu">enumerate</span>(stream.traces):</span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a>    data[:<span class="bu">len</span>(tr.data), i] <span class="op">=</span> tr.data</span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb2-20"><a href="#cb2-20" tabindex="-1"></a>plt.imshow(data, cmap<span class="op">=</span><span class="st">"gray"</span>, aspect<span class="op">=</span><span class="st">"auto"</span>, origin<span class="op">=</span><span class="st">"upper"</span>, interpolation<span class="op">=</span><span class="st">"none"</span>)</span>
<span id="cb2-21"><a href="#cb2-21" tabindex="-1"></a>plt.title(<span class="st">"Seismic Section (LINE01.sgy)"</span>)</span>
<span id="cb2-22"><a href="#cb2-22" tabindex="-1"></a>plt.xlabel(<span class="st">"Trace Number"</span>)</span>
<span id="cb2-23"><a href="#cb2-23" tabindex="-1"></a>plt.ylabel(<span class="st">"Time Sample"</span>)</span>
<span id="cb2-24"><a href="#cb2-24" tabindex="-1"></a>plt.colorbar(label<span class="op">=</span><span class="st">"Amplitude"</span>)</span>
<span id="cb2-25"><a href="#cb2-25" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>What this code does, step by step:</p>
<p>Read the file and collect traces: same reader as Example 1.</p>
<p>Determine array geometry: n_traces is the lateral dimension; max_len
is the longest trace length.</p>
<p>Allocate a section matrix: data is a two-dimensional array with shape
(time samples, trace number).</p>
<p>Populate the matrix: for each trace, copy its samples into the
corresponding column; shorter traces remain zero-padded at late
times.</p>
<p>Display the radargram: imshow renders amplitude as image
intensity.</p>
<p>origin=“upper” places early time at the top of the image.</p>
<p>aspect=“auto” allows traces to fill the figure width.</p>
<p>cmap=“gray” uses a neutral colour map suited to signed
amplitudes.</p>
<p>interpolation=“none” avoids smoothing that could hide thin
reflectors.</p>
<p>Interpretation note: continuous subhorizontal events suggest
layering; symmetric hyperbolas indicate compact objects. Polarity is
arbitrary at this stage and depends on plotting conventions.</p>
<p>Add-on checks on performace:</p>
<p>Verify whether zero padding at late times creates a visible edge; in
later processing you may want to trim to a common time window.</p>
<p>If position ticks are uneven, later steps should remap traces to true
distance before velocity analysis.</p>
<p>To relate time samples to actual time, multiply sample index by the
per-trace sample interval from headers.</p>
</div>
<div class="section level2">
<h2 id="example-3-inspect-acquisition-metadata">Example 3 — Inspect acquisition metadata<a class="anchor" aria-label="anchor" href="#example-3-inspect-acquisition-metadata"></a>
</h2>
<p>SEG-Y files store much more than amplitudes. Each trace contains a
header with information such as the number of samples, sample interval,
and trace sequence number. Reading these values is a first
quality-control step.</p>
<pre><code>from obspy.io.segy.segy import _read_segy

stream = _read_segy("LINE01.sgy", headonly=True)

# Access the first trace header
tr0 = stream.traces[0]

print("Number of samples:", tr0.header.number_of_samples)
print("Sample interval (microseconds):", tr0.header.sample_interval_in_ms_for_this_trace)
print("Trace sequence number:", tr0.header.trace_sequence_number_within_line)
</code></pre>
<p>What this code does, step by step:</p>
<p>headonly=True avoids loading amplitudes and reads only headers.</p>
<p>number_of_samples × sample_interval gives the total time window.</p>
<p>Trace sequence numbers are useful for checking completeness of the
dataset.</p>
<p>Inspecting headers ensures that later visualizations are correctly
scaled.</p>
</div>
<div class="section level2">
<h2 id="example-4-adding-a-time-axis-to-a-trace">Example 4 — Adding a time axis to a trace<a class="anchor" aria-label="anchor" href="#example-4-adding-a-time-axis-to-a-trace"></a>
</h2>
<p>Plots by sample index are useful, but a time axis makes the physics
clearer. We can build a time vector from the sample interval stored in
the header.</p>
<pre><code>import matplotlib.pyplot as plt
from obspy.io.segy.segy import _read_segy
import numpy as np

stream = _read_segy("LINE01.sgy", headonly=False)
tr0 = stream.traces[0]

# Extract sample interval (microseconds) and build time axis
dt = tr0.header.sample_interval_in_ms_for_this_trace  # in microseconds
n_samples = len(tr0.data)
time = np.arange(n_samples) * dt * 1e-6  # convert to seconds

# Plot trace with time axis
plt.figure(figsize=(6, 4))
plt.plot(time, tr0.data)
plt.title("First Trace with Time Axis")
plt.xlabel("Two-way travel time [s]")
plt.ylabel("Amplitude")
plt.grid(True)
plt.show()</code></pre>
<p>What this code does, step by step:</p>
<p>The x-axis now shows two-way travel time in seconds.</p>
<p>This connects the data to subsurface depth, once a velocity model is
assumed.</p>
<p>Early samples correspond to shallow reflections; later samples
correspond to deeper features.</p>
</div>
<div class="section level2">
<h2 id="example-5-applying-a-simple-gain">Example 5 — Applying a simple gain<a class="anchor" aria-label="anchor" href="#example-5-applying-a-simple-gain"></a>
</h2>
<p>Near-surface reflections are often strong, while deeper reflections
appear weak. A gain function can emphasize later arrivals. This example
applies a simple exponential gain to one trace.</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
from obspy.io.segy.segy import _read_segy

stream = _read_segy("LINE01.sgy", headonly=False)
tr0 = stream.traces[0]

# Build sample index array
n_samples = len(tr0.data)
time = np.arange(n_samples)

# Apply exponential gain
gain = np.exp(time / (0.2 * n_samples))  # adjust denominator to control strength
trace_gain = tr0.data * gain

# Compare original and gained traces
plt.figure(figsize=(6, 4))
plt.plot(time, tr0.data, label="Original")
plt.plot(time, trace_gain, label="With exponential gain", alpha=0.7)
plt.title("Trace with and without Gain")
plt.xlabel("Sample Index")
plt.ylabel("Amplitude")
plt.legend()
plt.grid(True)
plt.show()</code></pre>
<p>What this code does, step by step:</p>
<p>The exponential gain increases amplitudes at later times.</p>
<p>This helps reveal weak deeper events that might otherwise be
invisible.</p>
<p>The trade-off is that noise at late times is also amplified.</p>
<p>Students learn the importance of balancing clarity and noise.</p>
</div>
</div></section><section id="aio-AGC Implementation"><p>Content from <a href="AGC%20Implementation.html">AGC</a></p>
<hr>
<p>Last updated on 2025-09-07 |

        <a href="https://github.com/Azinkarimzad/Imaging_the_unseen/edit/main/episodes/AGC%20Implementation.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li><p>Why do GPR signals decrease in amplitude with increasing two-way
travel time?</p></li>
<li><p>What is the principle of Automatic Gain Control (AGC) in signal
processing?</p></li>
<li><p>How does the choice of window length influence the effect of AGC
on a radargram?</p></li>
<li><p>How can AGC be implemented in Python to enhance deeper
reflections in SEG-Y data?</p></li>
<li><p>What are the potential benefits and drawbacks of applying AGC to
GPR data?</p></li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li><p>Explain the physical reason for signal decay in GPR traces and
why amplitude balancing is needed.</p></li>
<li><p>Describe the concept of AGC as a sliding-window normalization
method.</p></li>
<li><p>Demonstrate the step-by-step implementation of AGC on a 2D data
section using Python.</p></li>
<li><p>Evaluate how window length selection affects signal visibility
and noise amplification.</p></li>
<li><p>Compare radargrams before and after AGC to interpret the
improvement in deeper reflections.</p></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li><p>GPR amplitudes decay with travel time due to geometric spreading,
absorption, and scattering.</p></li>
<li><p>Automatic Gain Control (AGC) rescales amplitudes within a moving
window to balance early and late signals.</p></li>
<li><p>Window length controls the behavior: short windows emphasize
local contrasts but may boost noise, long windows smooth variations but
may underrepresent weak reflections.</p></li>
<li><p>AGC does not recover true amplitudes; it enhances relative
visibility for interpretation.</p></li>
<li><p>In Python, AGC can be implemented by normalizing each trace
sample by the RMS of its surrounding window.</p></li>
</ul>
</div>
</div>
</div>
<div class="introduction">
<p>Automatic Gain Control (AGC) in GPR</p>
<p>One of the main challenges in Ground Penetrating Radar (GPR)
interpretation is that recorded amplitudes decrease with increasing
two-way travel time. This decay occurs because of several factors:
geometric spreading of the wavefront, intrinsic absorption by the
medium, and scattering losses. As a result, reflections from deeper
structures often appear weak compared to strong early arrivals near the
surface.</p>
<p>Automatic Gain Control (AGC) is a signal-processing technique
designed to correct this imbalance. Instead of applying a single global
gain function, AGC adjusts amplitudes locally using a sliding window.
Within each window, amplitudes are normalized relative to their average
energy (root mean square, RMS). This ensures that both shallow and deep
events are displayed with more balanced strength.</p>
<p>The effect of AGC depends strongly on the window length:</p>
<p>Short windows enhance small-scale features but may also amplify
random noise.</p>
<p>Long windows provide smoother balancing but may underemphasize weak
events.</p>
<p>It is important to remember that AGC modifies amplitudes for
visualization and interpretation rather than preserving true reflection
strength. In this lesson, we will implement AGC in Python, apply it to a
SEG-Y radargram, and compare sections before and after processing to see
how deeper reflections become clearer.</p>
<div class="section level2">
<h2 id="example-1-applying-automatic-gain-control-agc-to-a-radargram">Example 1 — Applying Automatic Gain Control (AGC) to a
radargram<a class="anchor" aria-label="anchor" href="#example-1-applying-automatic-gain-control-agc-to-a-radargram"></a>
</h2>
<p>apply_agc normalizes each sample by the RMS amplitude of its local
window. The window length determines how local the gain is. After
applying AGC, deeper reflections become more visible, although noise may
also be amplified. The plotted radargram now shows both shallow and deep
events with balanced amplitudes for interpretation.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">from</span> obspy.io.segy.segy <span class="im">import</span> _read_segy</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="kw">def</span> apply_agc(data, window_len):</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="co">    Apply automatic gain control (AGC) on a 2D seismic array.</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co">        data (ndarray): [samples x traces]</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="co">        window_len (int): Window length in samples</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a><span class="co">        ndarray: AGC-applied seismic section</span></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>    agc_data <span class="op">=</span> np.zeros_like(data)</span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>    half_window <span class="op">=</span> window_len <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(data.shape[<span class="dv">1</span>]):  <span class="co"># loop over traces</span></span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a>        trace <span class="op">=</span> data[:, i]</span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a>        agc_trace <span class="op">=</span> np.zeros_like(trace)</span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(trace)):</span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a>            start <span class="op">=</span> <span class="bu">max</span>(j <span class="op">-</span> half_window, <span class="dv">0</span>)</span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a>            end <span class="op">=</span> <span class="bu">min</span>(j <span class="op">+</span> half_window, <span class="bu">len</span>(trace))</span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a>            window <span class="op">=</span> trace[start:end]</span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a>            rms <span class="op">=</span> np.sqrt(np.mean(window <span class="op">**</span> <span class="dv">2</span>)) <span class="op">+</span> <span class="fl">1e-12</span>  <span class="co"># avoid divide by zero</span></span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a>            agc_trace[j] <span class="op">=</span> trace[j] <span class="op">/</span> rms</span>
<span id="cb1-29"><a href="#cb1-29" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" tabindex="-1"></a>        agc_data[:, i] <span class="op">=</span> agc_trace</span>
<span id="cb1-31"><a href="#cb1-31" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" tabindex="-1"></a>    <span class="cf">return</span> agc_data</span>
<span id="cb1-33"><a href="#cb1-33" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" tabindex="-1"></a><span class="co"># --- Load SEG-Y ---</span></span>
<span id="cb1-35"><a href="#cb1-35" tabindex="-1"></a>segy_file <span class="op">=</span> <span class="st">"LINE01.sgy"</span></span>
<span id="cb1-36"><a href="#cb1-36" tabindex="-1"></a>stream <span class="op">=</span> _read_segy(segy_file, headonly<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-37"><a href="#cb1-37" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" tabindex="-1"></a><span class="co"># --- Build data array ---</span></span>
<span id="cb1-39"><a href="#cb1-39" tabindex="-1"></a>n_traces <span class="op">=</span> <span class="bu">len</span>(stream.traces)</span>
<span id="cb1-40"><a href="#cb1-40" tabindex="-1"></a>max_len <span class="op">=</span> <span class="bu">max</span>(<span class="bu">len</span>(tr.data) <span class="cf">for</span> tr <span class="kw">in</span> stream.traces)</span>
<span id="cb1-41"><a href="#cb1-41" tabindex="-1"></a>data <span class="op">=</span> np.zeros((max_len, n_traces))</span>
<span id="cb1-42"><a href="#cb1-42" tabindex="-1"></a><span class="cf">for</span> i, tr <span class="kw">in</span> <span class="bu">enumerate</span>(stream.traces):</span>
<span id="cb1-43"><a href="#cb1-43" tabindex="-1"></a>    data[:<span class="bu">len</span>(tr.data), i] <span class="op">=</span> tr.data</span>
<span id="cb1-44"><a href="#cb1-44" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" tabindex="-1"></a><span class="co"># --- Apply AGC ---</span></span>
<span id="cb1-46"><a href="#cb1-46" tabindex="-1"></a>window_length <span class="op">=</span> <span class="dv">50</span>  <span class="co"># samples (adjust based on data)</span></span>
<span id="cb1-47"><a href="#cb1-47" tabindex="-1"></a>agc_result <span class="op">=</span> apply_agc(data, window_length)</span>
<span id="cb1-48"><a href="#cb1-48" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" tabindex="-1"></a><span class="co"># --- Plot ---</span></span>
<span id="cb1-50"><a href="#cb1-50" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb1-51"><a href="#cb1-51" tabindex="-1"></a>plt.imshow(agc_result, cmap<span class="op">=</span><span class="st">"gray"</span>, aspect<span class="op">=</span><span class="st">"auto"</span>, origin<span class="op">=</span><span class="st">"upper"</span>)</span>
<span id="cb1-52"><a href="#cb1-52" tabindex="-1"></a>plt.title(<span class="st">"Seismic Section with AGC (window = </span><span class="sc">{}</span><span class="st"> samples)"</span>.<span class="bu">format</span>(window_length))</span>
<span id="cb1-53"><a href="#cb1-53" tabindex="-1"></a>plt.xlabel(<span class="st">"Trace Number"</span>)</span>
<span id="cb1-54"><a href="#cb1-54" tabindex="-1"></a>plt.ylabel(<span class="st">"Time Sample"</span>)</span>
<span id="cb1-55"><a href="#cb1-55" tabindex="-1"></a>plt.colorbar(label<span class="op">=</span><span class="st">"Amplitude (AGC-normalized)"</span>)</span>
<span id="cb1-56"><a href="#cb1-56" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
<div class="section level2">
<h2 id="example-2-compare-radargram-before-and-after-agc">Example 2 — Compare radargram before and after AGC<a class="anchor" aria-label="anchor" href="#example-2-compare-radargram-before-and-after-agc"></a>
</h2>
<p>This example loads the SEG Y profile, builds the section matrix,
applies AGC with a chosen window, and plots the original and the AGC
result in separate figures for direct visual comparison.</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
from obspy.io.segy.segy import _read_segy

def apply_agc(data, window_len):
    n_samples, n_traces = data.shape
    agc_data = np.zeros_like(data)
    half_window = window_len // 2
    for i in range(n_traces):
        for j in range(n_samples):
            start = max(0, j - half_window)
            end = min(n_samples, j + half_window)
            rms = np.sqrt(np.mean(data[start:end, i]**2)) + 1e-12
            agc_data[j, i] = data[j, i] / rms
    return agc_data

# Load and assemble section
stream = _read_segy("LINE01.sgy", headonly=False)
n_traces = len(stream.traces)
max_len = max(len(tr.data) for tr in stream.traces)

data = np.zeros((max_len, n_traces))
for i, tr in enumerate(stream.traces):
    data[:len(tr.data), i] = tr.data

# Apply AGC
window_length = 50  # samples
agc_data = apply_agc(data, window_length)

# Plot original section
plt.figure(figsize=(12, 6))
plt.imshow(data, cmap="gray", aspect="auto", origin="upper", interpolation="none")
plt.title("Original Section (no gain)")
plt.xlabel("Trace Number")
plt.ylabel("Time Sample")
plt.colorbar(label="Amplitude")
plt.show()

# Plot AGC section
plt.figure(figsize=(12, 6))
plt.imshow(agc_data, cmap="gray", aspect="auto", origin="upper", interpolation="none")
plt.title(f"AGC Applied Section (Window = {window_length} samples)")
plt.xlabel("Trace Number")
plt.ylabel("Time Sample")
plt.colorbar(label="Normalized Amplitude")
plt.show()
</code></pre>
<p>Explanation:</p>
<p>The first figure shows the unscaled radargram where early strong
arrivals can mask deeper reflections.</p>
<p>The second figure shows the AGC result where deeper events are more
balanced against near-surface energy.</p>
<p>Use the same color map and plotting parameters so differences are due
to AGC only.</p>
</div>
<div class="section level2">
<h2 id="example-3-window-length-sensitivity-study">Example 3 — Window length sensitivity study<a class="anchor" aria-label="anchor" href="#example-3-window-length-sensitivity-study"></a>
</h2>
<p>AGC behavior depends on the window length. This example applies AGC
with several window lengths and shows separate figures so students can
judge the trade-offs.</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
from obspy.io.segy.segy import _read_segy

def apply_agc(data, window_len):
    n_samples, n_traces = data.shape
    agc_data = np.zeros_like(data)
    half_window = window_len // 2
    for i in range(n_traces):
        for j in range(n_samples):
            start = max(0, j - half_window)
            end = min(n_samples, j + half_window)
            rms = np.sqrt(np.mean(data[start:end, i]**2)) + 1e-12
            agc_data[j, i] = data[j, i] / rms
    return agc_data

# Load and assemble section (once)
stream = _read_segy("LINE01.sgy", headonly=False)
n_traces = len(stream.traces)
max_len = max(len(tr.data) for tr in stream.traces)

data = np.zeros((max_len, n_traces))
for i, tr in enumerate(stream.traces):
    data[:len(tr.data), i] = tr.data

# Try several window lengths (in samples)
window_list = [20, 50, 100, 200]

for w in window_list:
    agc_w = apply_agc(data, w)

    plt.figure(figsize=(12, 6))
    plt.imshow(agc_w, cmap="gray", aspect="auto", origin="upper", interpolation="none")
    plt.title(f"AGC Section — Window = {w} samples")
    plt.xlabel("Trace Number")
    plt.ylabel("Time Sample")
    plt.colorbar(label="Normalized Amplitude")
    plt.show()
</code></pre>
<p>Explanation and guidance:</p>
<p>Short windows, for example 20 samples, strongly equalize local
amplitudes. Small features pop out, but late-time noise can be
amplified.</p>
<p>Intermediate windows around 50 to 100 samples often give a good
balance for many GPR datasets.</p>
<p>Long windows such as 200 samples produce smoother results that
preserve broader trends but may underemphasize weak reflectors.</p>
<p>A practical rule of thumb is to select a window corresponding to a
few to several periods of the dominant frequency:</p>
<p><span class="math display">\[
\text{window_len} \approx k \times \frac{1}{f_c\,\Delta t}
\]</span></p>
<p>where f_c is the antenna center frequency and Δt is the sample
interval; choose k between roughly three and ten.</p>
</div>
</div></section><section id="aio-Background Removal"><p>Content from <a href="Background%20Removal.html">Background Removal</a></p>
<hr>
<p>Last updated on 2025-09-07 |

        <a href="https://github.com/Azinkarimzad/Imaging_the_unseen/edit/main/episodes/Background%20Removal.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li><p>What is background removal in GPR data processing?</p></li>
<li><p>Why is background removal needed for clearer
interpretation?</p></li>
<li><p>How can background removal be implemented
programmatically?</p></li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li><p>Define the concept of background in GPR sections and explain its
origin.</p></li>
<li><p>Demonstrate how to remove background by subtracting the average
trace.</p></li>
<li><p>Evaluate the effect of background removal on data clarity and
reflector visibility.</p></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li><p>Background in GPR sections often comes from consistent system
responses, coupling effects, or horizontal banding.</p></li>
<li><p>Removing the background enhances true reflections and reduces
horizontal noise.</p></li>
<li><p>A simple method is subtracting the mean trace across all
traces.</p></li>
</ul>
</div>
</div>
</div>
<div class="introduction">
<p>Ground Penetrating Radar (GPR) data often contain <strong>background
noise</strong> that is unrelated to true subsurface reflections.<br>
This background usually appears as horizontal banding or low-frequency
components repeated across all traces.<br>
It originates from several sources:<br>
- the direct wave and antenna ringing,<br>
- system electronics,<br>
- consistent ground coupling responses.</p>
<p>If left untreated, this background can mask weak reflections,
especially deeper ones.</p>
<p><strong>Background removal</strong> is a common preprocessing step
that improves the visibility of hyperbolas and stratigraphic
features.<br>
The simplest approach is to compute the <strong>average trace</strong>
across all traces in a section and subtract it from each individual
trace.<br>
This removes energy that is consistent everywhere (the “background”)
while preserving local variations that indicate subsurface features.</p>
<div class="section level2">
<h2 id="example-1-removing-background-by-subtracting-the-mean-trace">Example 1 — Removing background by subtracting the mean trace<a class="anchor" aria-label="anchor" href="#example-1-removing-background-by-subtracting-the-mean-trace"></a>
</h2>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># Background removal by subtracting mean trace</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="kw">def</span> remove_background(data):</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>    background <span class="op">=</span> np.mean(data, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>    <span class="cf">return</span> data <span class="op">-</span> background</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="co"># Apply it on your GPR section</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>data_bg_removed <span class="op">=</span> remove_background(agc_result)</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>plt.imshow(data_bg_removed, cmap<span class="op">=</span><span class="st">"gray"</span>, aspect<span class="op">=</span><span class="st">"auto"</span>, origin<span class="op">=</span><span class="st">"upper"</span>)</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>plt.title(<span class="st">"GPR Section with Background Removed"</span>)</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>plt.xlabel(<span class="st">"Trace Number"</span>)</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>plt.ylabel(<span class="st">"Time Sample"</span>)</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>plt.colorbar(label<span class="op">=</span><span class="st">"Amplitude"</span>)</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>Explanation:</p>
<p>Define the function</p>
<p>np.mean(data, axis=1, keepdims=True) computes the average amplitude
across all traces, at each time sample.</p>
<p>The result is a “mean trace” representing the background that is
common to all traces.</p>
<p>keepdims=True preserves the two-dimensional shape so subtraction
works cleanly.</p>
<p>Subtract the background</p>
<p>data - background removes this mean trace from each column (trace) in
the data section.</p>
<p>What remains are relative deviations, i.e. actual subsurface
reflections.</p>
<p>Apply to processed section</p>
<p>In this case, agc_result is the section after Automatic Gain
Control.</p>
<p>Applying background removal after AGC makes weaker reflectors
clearer.</p>
<p>Plot</p>
<p>imshow shows the new radargram with background removed.</p>
<p>Horizontal banding should be reduced, and hyperbolic events should
stand out.</p>
</div>
<div class="section level2">
<h2 id="example-2-visual-comparison-before-vs-after-background-removal">Example 2 — Visual comparison: before vs after background
removal<a class="anchor" aria-label="anchor" href="#example-2-visual-comparison-before-vs-after-background-removal"></a>
</h2>
<p>This example shows the original section and the background-removed
section, so learners can judge the effect directly.</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt

def remove_background(data):
    # Estimate background as the mean across traces at each time sample
    background = np.mean(data, axis=1, keepdims=True)
    # Subtract the background from every trace
    return data - background, background

# Assume `agc_result` is your AGC-processed section with shape [samples, traces]
data_bg_removed, estimated_background = remove_background(agc_result)

# Plot original section
plt.figure(figsize=(12, 5))
plt.imshow(agc_result, cmap="gray", aspect="auto", origin="upper", interpolation="none")
plt.title("Original Section (after AGC, before background removal)")
plt.xlabel("Trace Number")
plt.ylabel("Time Sample")
plt.colorbar(label="Amplitude")
plt.show()

# Plot background-removed section
plt.figure(figsize=(12, 5))
plt.imshow(data_bg_removed, cmap="gray", aspect="auto", origin="upper", interpolation="none")
plt.title("Section after Background Removal (mean trace subtraction)")
plt.xlabel("Trace Number")
plt.ylabel("Time Sample")
plt.colorbar(label="Amplitude")
plt.show()

# Optional: visualize the estimated background (as an image)
plt.figure(figsize=(12, 5))
plt.imshow(np.repeat(estimated_background, agc_result.shape[1], axis=1),
           cmap="gray", aspect="auto", origin="upper", interpolation="none")
plt.title("Estimated Background (mean across traces, repeated laterally)")
plt.xlabel("Trace Number")
plt.ylabel("Time Sample")
plt.colorbar(label="Amplitude")
plt.show()</code></pre>
<p>Explanation:</p>
<p>The estimated background is the mean across traces at each time
sample; repeating it laterally shows the component being removed.</p>
<p>Comparing the two sections highlights how horizontal banding is
reduced and diffractive features become clearer.</p>
</div>
<div class="section level2">
<h2 id="example-3-robust-background-removal-using-median-trace">Example 3 — Robust background removal using median trace<a class="anchor" aria-label="anchor" href="#example-3-robust-background-removal-using-median-trace"></a>
</h2>
<p>Mean subtraction can be sensitive to a few large amplitudes. A median
is more robust when strong reflectors or outliers are present. This
example subtracts the per-sample median across traces.</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt

def remove_background_median(data):
    # Estimate background as the median across traces at each time sample (robust to outliers)
    background_med = np.median(data, axis=1, keepdims=True)
    # Subtract the median background from every trace
    return data - background_med, background_med

# Apply robust background removal
data_bg_removed_med, estimated_background_med = remove_background_median(agc_result)

# Plot result
plt.figure(figsize=(12, 5))
plt.imshow(data_bg_removed_med, cmap="gray", aspect="auto", origin="upper", interpolation="none")
plt.title("Section after Background Removal (median trace subtraction)")
plt.xlabel("Trace Number")
plt.ylabel("Time Sample")
plt.colorbar(label="Amplitude")
plt.show()</code></pre>
<p>Explanation:</p>
<p>Median across traces at each time sample suppresses persistent
horizontal components while resisting the influence of a few large
events.</p>
<p>Resulting sections often show cleaner backgrounds when strong
isolated reflectors are present.</p>
</div>
</div></section><section id="aio-Time-Zero Correction"><p>Content from <a href="Time-Zero%20Correction.html">Time-Zero Correction</a></p>
<hr>
<p>Last updated on 2025-09-07 |

        <a href="https://github.com/Azinkarimzad/Imaging_the_unseen/edit/main/episodes/Time-Zero%20Correction.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What does time-zero represent in a GPR trace?<br>
</li>
<li>Why do system delays and antenna geometry cause time-zero to be
shifted?<br>
</li>
<li>How can first breaks be detected automatically in traces?<br>
</li>
<li>What happens to interpretation if time-zero is not corrected?<br>
</li>
<li>How can we compare sections before and after time-zero
correction?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Define time-zero and explain its importance for accurate depth
conversion.<br>
</li>
<li>Identify common causes of time-zero shifts in GPR data.<br>
</li>
<li>Demonstrate an automatic time-zero correction workflow using
first-break detection.<br>
</li>
<li>Visualize the distribution of first-break picks and assess their
consistency.<br>
</li>
<li>Compare radargrams before and after correction to evaluate
improvements.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>Time-zero is the instant when the transmitted pulse enters the
ground.<br>
</li>
<li>System delays and geometry shift the apparent time-zero away from
zero samples.<br>
</li>
<li>Automatic methods detect first breaks using the signal envelope and
amplitude thresholds.<br>
</li>
<li>Aligning traces to a common first break ensures consistent
interpretation.<br>
</li>
<li>Time-zero correction is essential for reliable time-to-depth
conversion and structural imaging.</li>
</ul>
</div>
</div>
</div>
<div class="section level2 introduction">
<h2 id="time-zero-in-gpr">Time-Zero in GPR<a class="anchor" aria-label="anchor" href="#time-zero-in-gpr"></a>
</h2>
<p>In Ground Penetrating Radar (GPR), <strong>time-zero</strong> is the
reference point corresponding to the instant when the transmitted
electromagnetic pulse leaves the antenna and enters the medium. Ideally,
this should appear at the start of every recorded trace. In practice,
traces often show a shift in time-zero due to:</p>
<ul>
<li>electronic delays in the system trigger and recording,</li>
<li>physical separation between transmitting and receiving
antennas,</li>
<li>coupling effects between antennas and the ground surface.</li>
</ul>
<p>These shifts cause reflections to appear later than their true
arrival time. If left uncorrected, such misalignment leads to errors in
estimating depths and comparing events across traces.</p>
<p><strong>Time-zero correction</strong> realigns all traces so that
their effective start time corresponds to the true wave entry. This
process improves consistency and ensures that travel times can be
correctly converted to depth using velocity models.</p>
<p>In this lesson we use an <strong>automatic first-break detection
method</strong>. The Hilbert transform is applied to compute the signal
envelope, and a threshold relative to the maximum amplitude is used to
pick the first significant arrival in each trace. The median of these
first breaks defines the common alignment point. Traces are then shifted
to this reference, and the section is trimmed so the new time axis
begins at zero.</p>
<p>This correction is essential before velocity analysis, migration, or
quantitative interpretation of GPR data. It is a standard preprocessing
step in both engineering and archaeological applications.</p>
</div>
<section><h2 class="section-heading" id="example-1-automatic-time-zero-correction-using-first-break-detection">Example 1 — Automatic Time-Zero Correction using First-Break
Detection<a class="anchor" aria-label="anchor" href="#example-1-automatic-time-zero-correction-using-first-break-detection"></a>
</h2>
<hr class="half-width">
<p>The following code implements an automatic method to detect first
breaks in GPR traces and realign all traces so that their time-zero is
consistent. This approach uses the Hilbert transform to compute the
signal envelope and an amplitude threshold to identify the first
arrival.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">from</span> obspy.io.segy.segy <span class="im">import</span> _read_segy</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">from</span> scipy.signal <span class="im">import</span> hilbert</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="kw">def</span> detect_first_break(trace, threshold_ratio<span class="op">=</span><span class="fl">0.05</span>, min_sample<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co">    Detect the first break index using an amplitude threshold on the envelope,</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co">    starting the search from a specified minimum sample.</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>    envelope <span class="op">=</span> np.<span class="bu">abs</span>(hilbert(trace))</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>    threshold <span class="op">=</span> threshold_ratio <span class="op">*</span> np.<span class="bu">max</span>(envelope)</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(min_sample, <span class="bu">len</span>(envelope)):</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>        <span class="cf">if</span> envelope[i] <span class="op">&gt;</span> threshold:</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>            <span class="cf">return</span> i</span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>    <span class="cf">return</span> min_sample  <span class="co"># fallback</span></span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a><span class="kw">def</span> time_zero_correction_auto(data, threshold_ratio<span class="op">=</span><span class="fl">0.05</span>, min_sample<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a><span class="co">    Automatically estimate the target sample (median of all first breaks),</span></span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a><span class="co">    align all traces to it, and trim the section to re-zero time.</span></span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a>    n_samples, n_traces <span class="op">=</span> data.shape</span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a>    shifts <span class="op">=</span> [detect_first_break(data[:, i], threshold_ratio, min_sample) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_traces)]</span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a>    <span class="co"># Estimate target sample using median of detected first breaks</span></span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a>    target_sample <span class="op">=</span> <span class="bu">int</span>(np.median(shifts))</span>
<span id="cb1-29"><a href="#cb1-29" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Estimated target sample for alignment: </span><span class="sc">{</span>target_sample<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-30"><a href="#cb1-30" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" tabindex="-1"></a>    corrected <span class="op">=</span> np.zeros_like(data)</span>
<span id="cb1-32"><a href="#cb1-32" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_traces):</span>
<span id="cb1-33"><a href="#cb1-33" tabindex="-1"></a>        shift <span class="op">=</span> shifts[i] <span class="op">-</span> target_sample</span>
<span id="cb1-34"><a href="#cb1-34" tabindex="-1"></a>        trace <span class="op">=</span> data[:, i]</span>
<span id="cb1-35"><a href="#cb1-35" tabindex="-1"></a>        shifted_trace <span class="op">=</span> np.zeros_like(trace)</span>
<span id="cb1-36"><a href="#cb1-36" tabindex="-1"></a>        <span class="cf">if</span> shift <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb1-37"><a href="#cb1-37" tabindex="-1"></a>            shifted_trace[:<span class="bu">len</span>(trace)<span class="op">-</span>shift] <span class="op">=</span> trace[shift:]</span>
<span id="cb1-38"><a href="#cb1-38" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-39"><a href="#cb1-39" tabindex="-1"></a>            shifted_trace[<span class="op">-</span>shift:] <span class="op">=</span> trace[:<span class="bu">len</span>(trace)<span class="op">+</span>shift]</span>
<span id="cb1-40"><a href="#cb1-40" tabindex="-1"></a>        corrected[:, i] <span class="op">=</span> shifted_trace</span>
<span id="cb1-41"><a href="#cb1-41" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" tabindex="-1"></a>    <span class="co"># Trim the top 'target_sample' rows so time-zero starts from there</span></span>
<span id="cb1-43"><a href="#cb1-43" tabindex="-1"></a>    corrected_trimmed <span class="op">=</span> corrected[target_sample:, :]</span>
<span id="cb1-44"><a href="#cb1-44" tabindex="-1"></a>    <span class="cf">return</span> corrected_trimmed, shifts, target_sample</span>
<span id="cb1-45"><a href="#cb1-45" tabindex="-1"></a></span>
<span id="cb1-46"><a href="#cb1-46" tabindex="-1"></a><span class="co"># --- Load GPR (SEGY) data ---</span></span>
<span id="cb1-47"><a href="#cb1-47" tabindex="-1"></a>segy_file <span class="op">=</span> <span class="st">"LINE01.sgy"</span></span>
<span id="cb1-48"><a href="#cb1-48" tabindex="-1"></a>stream <span class="op">=</span> _read_segy(segy_file, headonly<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-49"><a href="#cb1-49" tabindex="-1"></a></span>
<span id="cb1-50"><a href="#cb1-50" tabindex="-1"></a><span class="co"># Build 2D data array [samples x traces]</span></span>
<span id="cb1-51"><a href="#cb1-51" tabindex="-1"></a>n_traces <span class="op">=</span> <span class="bu">len</span>(stream.traces)</span>
<span id="cb1-52"><a href="#cb1-52" tabindex="-1"></a>max_len <span class="op">=</span> <span class="bu">max</span>(<span class="bu">len</span>(tr.data) <span class="cf">for</span> tr <span class="kw">in</span> stream.traces)</span>
<span id="cb1-53"><a href="#cb1-53" tabindex="-1"></a>data <span class="op">=</span> np.zeros((max_len, n_traces))</span>
<span id="cb1-54"><a href="#cb1-54" tabindex="-1"></a><span class="cf">for</span> i, tr <span class="kw">in</span> <span class="bu">enumerate</span>(stream.traces):</span>
<span id="cb1-55"><a href="#cb1-55" tabindex="-1"></a>    data[:<span class="bu">len</span>(tr.data), i] <span class="op">=</span> tr.data</span>
<span id="cb1-56"><a href="#cb1-56" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" tabindex="-1"></a><span class="co"># --- Auto Time-Zero Correction ---</span></span>
<span id="cb1-58"><a href="#cb1-58" tabindex="-1"></a>threshold_ratio <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb1-59"><a href="#cb1-59" tabindex="-1"></a>min_sample <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb1-60"><a href="#cb1-60" tabindex="-1"></a>corrected_data, shifts, target_sample <span class="op">=</span> time_zero_correction_auto(data, threshold_ratio, min_sample)</span>
<span id="cb1-61"><a href="#cb1-61" tabindex="-1"></a></span>
<span id="cb1-62"><a href="#cb1-62" tabindex="-1"></a><span class="co"># --- First-Break Shift Histogram ---</span></span>
<span id="cb1-63"><a href="#cb1-63" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">3</span>))</span>
<span id="cb1-64"><a href="#cb1-64" tabindex="-1"></a>sns.histplot(shifts, bins<span class="op">=</span><span class="dv">20</span>, kde<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-65"><a href="#cb1-65" tabindex="-1"></a>plt.title(<span class="st">"Distribution of First-Break Shifts (Samples)"</span>)</span>
<span id="cb1-66"><a href="#cb1-66" tabindex="-1"></a>plt.xlabel(<span class="st">"Sample"</span>)</span>
<span id="cb1-67"><a href="#cb1-67" tabindex="-1"></a>plt.ylabel(<span class="st">"Frequency"</span>)</span>
<span id="cb1-68"><a href="#cb1-68" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb1-69"><a href="#cb1-69" tabindex="-1"></a>plt.show()</span>
<span id="cb1-70"><a href="#cb1-70" tabindex="-1"></a></span>
<span id="cb1-71"><a href="#cb1-71" tabindex="-1"></a><span class="co"># --- Overlay Original vs Corrected for One Trace ---</span></span>
<span id="cb1-72"><a href="#cb1-72" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb1-73"><a href="#cb1-73" tabindex="-1"></a>idx <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb1-74"><a href="#cb1-74" tabindex="-1"></a>plt.plot(data[:, idx], label<span class="op">=</span><span class="st">"Original"</span>, alpha<span class="op">=</span><span class="fl">0.6</span>)</span>
<span id="cb1-75"><a href="#cb1-75" tabindex="-1"></a>aligned <span class="op">=</span> np.zeros_like(data[:, idx])</span>
<span id="cb1-76"><a href="#cb1-76" tabindex="-1"></a>shift <span class="op">=</span> shifts[idx] <span class="op">-</span> target_sample</span>
<span id="cb1-77"><a href="#cb1-77" tabindex="-1"></a><span class="cf">if</span> shift <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb1-78"><a href="#cb1-78" tabindex="-1"></a>    aligned[:<span class="bu">len</span>(aligned) <span class="op">-</span> shift] <span class="op">=</span> data[:, idx][shift:]</span>
<span id="cb1-79"><a href="#cb1-79" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb1-80"><a href="#cb1-80" tabindex="-1"></a>    aligned[<span class="op">-</span>shift:] <span class="op">=</span> data[:, idx][:<span class="bu">len</span>(aligned) <span class="op">+</span> shift]</span>
<span id="cb1-81"><a href="#cb1-81" tabindex="-1"></a>plt.plot(aligned[target_sample:], label<span class="op">=</span><span class="st">"Corrected"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb1-82"><a href="#cb1-82" tabindex="-1"></a>plt.title(<span class="ss">f"Trace </span><span class="sc">{</span>idx<span class="sc">}</span><span class="ss"> - Original vs Auto-Aligned"</span>)</span>
<span id="cb1-83"><a href="#cb1-83" tabindex="-1"></a>plt.xlabel(<span class="st">"Sample"</span>)</span>
<span id="cb1-84"><a href="#cb1-84" tabindex="-1"></a>plt.ylabel(<span class="st">"Amplitude"</span>)</span>
<span id="cb1-85"><a href="#cb1-85" tabindex="-1"></a>plt.legend()</span>
<span id="cb1-86"><a href="#cb1-86" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb1-87"><a href="#cb1-87" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb1-88"><a href="#cb1-88" tabindex="-1"></a>plt.show()</span>
<span id="cb1-89"><a href="#cb1-89" tabindex="-1"></a></span>
<span id="cb1-90"><a href="#cb1-90" tabindex="-1"></a><span class="co"># --- Plot First-Break Picks on Sample Traces ---</span></span>
<span id="cb1-91"><a href="#cb1-91" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb1-92"><a href="#cb1-92" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb1-93"><a href="#cb1-93" tabindex="-1"></a>    idx <span class="op">=</span> i <span class="op">*</span> (n_traces <span class="op">//</span> <span class="dv">5</span>)</span>
<span id="cb1-94"><a href="#cb1-94" tabindex="-1"></a>    plt.plot(data[:, idx], label<span class="op">=</span><span class="ss">f"Trace </span><span class="sc">{</span>idx<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-95"><a href="#cb1-95" tabindex="-1"></a>    plt.axvline(x<span class="op">=</span>shifts[idx], color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb1-96"><a href="#cb1-96" tabindex="-1"></a>plt.axhline(target_sample, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, label<span class="op">=</span><span class="st">'Auto Target Sample'</span>)</span>
<span id="cb1-97"><a href="#cb1-97" tabindex="-1"></a>plt.title(<span class="st">"First-Break Picks on Sample Traces"</span>)</span>
<span id="cb1-98"><a href="#cb1-98" tabindex="-1"></a>plt.xlabel(<span class="st">"Sample"</span>)</span>
<span id="cb1-99"><a href="#cb1-99" tabindex="-1"></a>plt.ylabel(<span class="st">"Amplitude"</span>)</span>
<span id="cb1-100"><a href="#cb1-100" tabindex="-1"></a>plt.legend()</span>
<span id="cb1-101"><a href="#cb1-101" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb1-102"><a href="#cb1-102" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb1-103"><a href="#cb1-103" tabindex="-1"></a>plt.show()</span>
<span id="cb1-104"><a href="#cb1-104" tabindex="-1"></a></span>
<span id="cb1-105"><a href="#cb1-105" tabindex="-1"></a><span class="co"># --- Full Section: Before vs After Correction ---</span></span>
<span id="cb1-106"><a href="#cb1-106" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">6</span>), sharey<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-107"><a href="#cb1-107" tabindex="-1"></a></span>
<span id="cb1-108"><a href="#cb1-108" tabindex="-1"></a>axs[<span class="dv">0</span>].imshow(data, cmap<span class="op">=</span><span class="st">"gray"</span>, aspect<span class="op">=</span><span class="st">"auto"</span>, origin<span class="op">=</span><span class="st">"upper"</span>)</span>
<span id="cb1-109"><a href="#cb1-109" tabindex="-1"></a>axs[<span class="dv">0</span>].set_title(<span class="st">"Before Time-Zero Correction"</span>)</span>
<span id="cb1-110"><a href="#cb1-110" tabindex="-1"></a>axs[<span class="dv">0</span>].set_xlabel(<span class="st">"Trace"</span>)</span>
<span id="cb1-111"><a href="#cb1-111" tabindex="-1"></a>axs[<span class="dv">0</span>].set_ylabel(<span class="st">"Sample"</span>)</span>
<span id="cb1-112"><a href="#cb1-112" tabindex="-1"></a></span>
<span id="cb1-113"><a href="#cb1-113" tabindex="-1"></a>axs[<span class="dv">1</span>].imshow(corrected_data, cmap<span class="op">=</span><span class="st">"gray"</span>, aspect<span class="op">=</span><span class="st">"auto"</span>, origin<span class="op">=</span><span class="st">"upper"</span>)</span>
<span id="cb1-114"><a href="#cb1-114" tabindex="-1"></a>axs[<span class="dv">1</span>].set_title(<span class="ss">f"After Auto Time-Zero Correction (Aligned to Sample </span><span class="sc">{</span>target_sample<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb1-115"><a href="#cb1-115" tabindex="-1"></a>axs[<span class="dv">1</span>].set_xlabel(<span class="st">"Trace"</span>)</span>
<span id="cb1-116"><a href="#cb1-116" tabindex="-1"></a></span>
<span id="cb1-117"><a href="#cb1-117" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb1-118"><a href="#cb1-118" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>Step-by-step explanation</p>
<p>First-break detection</p>
<p>The Hilbert transform computes the analytic signal; its absolute
value gives the envelope.</p>
<p>The code sets a threshold at 5% (threshold_ratio=0.05) of the maximum
envelope.</p>
<p>The first sample exceeding this threshold (after min_sample) is
picked as the first break.</p>
<p>Automatic alignment</p>
<p>All traces are analyzed, producing a list of first-break indices
(shifts).</p>
<p>The median of these indices defines the target sample for
alignment.</p>
<p>Each trace is shifted so that its first break matches this
target.</p>
<p>Section trimming</p>
<p>Samples above the target are removed, so the new section begins at a
common time-zero.</p>
<p>Quality control plots</p>
<p>A histogram of first breaks shows their distribution and helps check
consistency.</p>
<p>A trace overlay (original vs corrected) illustrates the
alignment.</p>
<p>Vertical lines on sample traces visualize first-break picks.</p>
<p>Side-by-side radargrams show the effect of correction at the section
scale.</p>
<p>Interpretation</p>
<p>After correction, all traces share the same starting point, enabling
accurate depth conversion.</p>
<p>Misalignments due to system delays are removed, improving reflector
continuity.</p>
<p>The method is automatic but can be adjusted (e.g., threshold ratio,
minimum sample) to fit data characteristics.</p>
</section><section><h2 class="section-heading" id="example-2-manual-time-zero-correction-using-a-reference-trace">Example 2 — Manual Time-Zero Correction using a Reference Trace<a class="anchor" aria-label="anchor" href="#example-2-manual-time-zero-correction-using-a-reference-trace"></a>
</h2>
<hr class="half-width">
<p>In some cases, automatic picking may not be reliable (e.g. noisy
data, strong early clutter).<br>
A simpler approach is to pick a <strong>reference trace</strong>
manually and align all other traces to its first break.</p>
<pre><code># --- Pick a reference trace manually ---
ref_idx = 500  # example: middle trace as reference
ref_trace = data[:, ref_idx]

# Detect first break on reference trace
ref_fb = detect_first_break(ref_trace, threshold_ratio=0.05, min_sample=5)
print(f"Reference trace index: {ref_idx}, First break sample: {ref_fb}")

# Detect first breaks on all traces
all_fb = [detect_first_break(data[:, i], threshold_ratio=0.05, min_sample=5) for i in range(n_traces)]

# Align traces to the reference first break
corrected_manual = np.zeros_like(data)
for i in range(n_traces):
    shift = all_fb[i] - ref_fb
    trace = data[:, i]
    shifted_trace = np.zeros_like(trace)
    if shift &gt;= 0:
        shifted_trace[:len(trace)-shift] = trace[shift:]
    else:
        shifted_trace[-shift:] = trace[:len(trace)+shift]
    corrected_manual[:, i] = shifted_trace

# Trim so time-zero begins at the reference first break
corrected_manual = corrected_manual[ref_fb:, :]

# Plot before and after
fig, axs = plt.subplots(1, 2, figsize=(14, 6), sharey=False)
axs[0].imshow(data, cmap="gray", aspect="auto", origin="upper")
axs[0].set_title("Before Manual Time-Zero Correction")
axs[0].set_xlabel("Trace")
axs[0].set_ylabel("Sample")

axs[1].imshow(corrected_manual, cmap="gray", aspect="auto", origin="upper")
axs[1].set_title(f"After Manual Correction (Aligned to Trace {ref_idx})")
axs[1].set_xlabel("Trace")

plt.tight_layout()
plt.show()</code></pre>
<p>Explanation</p>
<p>A reference trace is chosen manually (here: index 500).</p>
<p>Its first break defines the target time-zero.</p>
<p>All other traces are shifted relative to this reference.</p>
<p>Useful when automatic methods pick inconsistent breaks due to noise
or strong clutter.</p>
<p>Less robust if the reference trace itself is distorted, so careful
selection is required.</p>
</section><section><h2 class="section-heading" id="example-3-visualizing-first-break-picks-across-the-section">Example 3 — Visualizing First-Break Picks Across the Section<a class="anchor" aria-label="anchor" href="#example-3-visualizing-first-break-picks-across-the-section"></a>
</h2>
<hr class="half-width">
<p>To check the reliability of time-zero correction, it is useful to
overlay first-break picks on top of the raw section.</p>
<pre><code># Detect first breaks on all traces (reuse detect_first_break function)
first_breaks = [detect_first_break(data[:, i], threshold_ratio=0.05, min_sample=5) for i in range(n_traces)]

# Plot section with first-break picks overlaid
plt.figure(figsize=(12, 6))
plt.imshow(data, cmap="gray", aspect="auto", origin="upper")
plt.scatter(np.arange(n_traces), first_breaks, color='red', s=10, label='First breaks')
plt.title("Raw Section with First-Break Picks")
plt.xlabel("Trace Number")
plt.ylabel("Sample Index")
plt.legend()
plt.show()</code></pre>
<p>Explanation</p>
<p>Each red point marks the picked first break for one trace.</p>
<p>A consistent horizontal band of picks indicates reliable automatic
detection.</p>
<p>Large scatter suggests noise or variable coupling; parameters
(threshold, minimum sample) may need adjusting.</p>
<p>This visualization helps students evaluate whether the correction
will be successful before applying shifts.</p>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-Bandpass Filtering"><p>Content from <a href="Bandpass%20Filtering.html">Bandpass Filtering</a></p>
<hr>
<p>Last updated on 2025-09-07 |

        <a href="https://github.com/Azinkarimzad/Imaging_the_unseen/edit/main/episodes/Bandpass%20Filtering.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What is a bandpass filter in the context of GPR signal
processing?</li>
<li>Why apply a bandpass filter to GPR traces before
interpretation?</li>
<li>How do sampling frequency and Nyquist frequency constrain the choice
of cutoffs?</li>
<li>How does zero-phase filtering affect waveform shape compared with
causal filtering?</li>
<li>How can frequency spectra guide the selection of passband
limits?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Define bandpass filtering and relate it to antenna bandwidth and
recorded noise.</li>
<li>Compute sampling and Nyquist frequencies from SEG Y headers and
validate cutoffs.</li>
<li>Apply a zero-phase Butterworth bandpass to a 2D GPR section without
altering your code.</li>
<li>Compare radargrams and trace spectra before and after filtering to
assess effectiveness.</li>
<li>Describe trade-offs when tightening or relaxing the passband.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>GPR data often contain low-frequency drift and high-frequency noise;
a bandpass suppresses both.</li>
<li>Cutoffs must lie within (0, Nyquist); selecting them near the
antenna’s effective bandwidth improves SNR.</li>
<li>Zero-phase forward-backward filtering (filtfilt) preserves arrival
timing and polarity.</li>
<li>Overly narrow passbands may distort wavelets or remove useful
signal.</li>
<li>Frequency spectra of representative traces help justify passband
choices quantitatively.</li>
</ul>
</div>
</div>
</div>
<div class="introduction">
<p>GPR antennas radiate broadband pulses with finite bandwidth. Recorded
sections typically include low-frequency components from coupling or
instrumentation and high-frequency noise from electronics or
environment. A <strong>bandpass filter</strong> retains a chosen
frequency band while attenuating energy below and above it. In practice,
cutoffs should respect the <strong>Nyquist frequency</strong> and
bracket the dominant signal band suggested by the antenna type and the
observed spectra.</p>
<p>This lesson applies a <strong>zero-phase Butterworth
bandpass</strong> to a 2D section. Zero-phase filtering via
forward-backward application avoids phase distortion, so reflector
timing is preserved. We compute sampling and Nyquist frequencies from
SEG Y headers, apply the filter trace-by-trace, and evaluate the result
using both images and amplitude spectra.</p>
</div>
<section><h2 class="section-heading" id="example-1-zero-phase-butterworth-bandpass-on-a-2d-gpr-section">Example 1 — Zero-phase Butterworth bandpass on a 2D GPR section<a class="anchor" aria-label="anchor" href="#example-1-zero-phase-butterworth-bandpass-on-a-2d-gpr-section"></a>
</h2>
<hr class="half-width">
<p>The code below reads a SEG Y profile, derives the sampling frequency,
applies a fourth-order Butterworth bandpass with cutoffs as percentages
of Nyquist, and compares sections and spectra before and after
filtering.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">from</span> scipy.signal <span class="im">import</span> butter, filtfilt</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">from</span> obspy.io.segy.segy <span class="im">import</span> _read_segy</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="kw">def</span> bandpass_filter(data, lowcut, highcut, fs, order<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>    nyquist <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> fs</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>    low <span class="op">=</span> lowcut <span class="op">/</span> nyquist</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>    high <span class="op">=</span> highcut <span class="op">/</span> nyquist</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="dv">0</span> <span class="op">&lt;</span> low <span class="op">&lt;</span> <span class="dv">1</span> <span class="kw">or</span> <span class="kw">not</span> <span class="dv">0</span> <span class="op">&lt;</span> high <span class="op">&lt;</span> <span class="dv">1</span>:</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Cutoff frequencies must be within (0, </span><span class="sc">{</span>nyquist<span class="sc">:.2f}</span><span class="ss"> Hz). Got low=</span><span class="sc">{</span>lowcut<span class="sc">}</span><span class="ss">, high=</span><span class="sc">{</span>highcut<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>    b, a <span class="op">=</span> butter(order, [low, high], btype<span class="op">=</span><span class="st">'band'</span>)</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>    </span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>    filtered <span class="op">=</span> np.zeros_like(data)</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(data.shape[<span class="dv">1</span>]):</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>        filtered[:, i] <span class="op">=</span> filtfilt(b, a, data[:, i])</span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>    <span class="cf">return</span> filtered</span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a><span class="kw">def</span> plot_frequency_spectrum(trace, fs, title):</span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a><span class="co">    Plot frequency amplitude spectrum of a single trace.</span></span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(trace)</span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a>    freqs <span class="op">=</span> np.fft.rfftfreq(n, d<span class="op">=</span><span class="dv">1</span><span class="op">/</span>fs)</span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a>    spectrum <span class="op">=</span> np.<span class="bu">abs</span>(np.fft.rfft(trace))</span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a>    </span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a>    plt.plot(freqs <span class="op">/</span> <span class="fl">1e6</span>, spectrum, label<span class="op">=</span>title)  <span class="co"># MHz</span></span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a>    plt.xlabel(<span class="st">"Frequency (MHz)"</span>)</span>
<span id="cb1-29"><a href="#cb1-29" tabindex="-1"></a>    plt.ylabel(<span class="st">"Amplitude"</span>)</span>
<span id="cb1-30"><a href="#cb1-30" tabindex="-1"></a>    plt.grid(<span class="va">True</span>)</span>
<span id="cb1-31"><a href="#cb1-31" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" tabindex="-1"></a><span class="co"># --- Load SEG-Y GPR data ---</span></span>
<span id="cb1-33"><a href="#cb1-33" tabindex="-1"></a>segy_file <span class="op">=</span> <span class="st">"LINE01.sgy"</span></span>
<span id="cb1-34"><a href="#cb1-34" tabindex="-1"></a>stream <span class="op">=</span> _read_segy(segy_file, headonly<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-35"><a href="#cb1-35" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" tabindex="-1"></a><span class="co"># Build 2D data array [samples x traces]</span></span>
<span id="cb1-37"><a href="#cb1-37" tabindex="-1"></a>n_traces <span class="op">=</span> <span class="bu">len</span>(stream.traces)</span>
<span id="cb1-38"><a href="#cb1-38" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="bu">max</span>(<span class="bu">len</span>(tr.data) <span class="cf">for</span> tr <span class="kw">in</span> stream.traces)</span>
<span id="cb1-39"><a href="#cb1-39" tabindex="-1"></a>data <span class="op">=</span> np.zeros((n_samples, n_traces))</span>
<span id="cb1-40"><a href="#cb1-40" tabindex="-1"></a><span class="cf">for</span> i, tr <span class="kw">in</span> <span class="bu">enumerate</span>(stream.traces):</span>
<span id="cb1-41"><a href="#cb1-41" tabindex="-1"></a>    data[:<span class="bu">len</span>(tr.data), i] <span class="op">=</span> tr.data</span>
<span id="cb1-42"><a href="#cb1-42" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" tabindex="-1"></a><span class="co"># --- Sampling rate ---</span></span>
<span id="cb1-44"><a href="#cb1-44" tabindex="-1"></a>dt_us <span class="op">=</span> stream.binary_file_header.sample_interval_in_microseconds  <span class="co"># microseconds</span></span>
<span id="cb1-45"><a href="#cb1-45" tabindex="-1"></a><span class="cf">if</span> dt_us <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-46"><a href="#cb1-46" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Sample interval is missing or zero in SEG-Y header. Set manually if needed."</span>)</span>
<span id="cb1-47"><a href="#cb1-47" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" tabindex="-1"></a>fs <span class="op">=</span> <span class="fl">1e6</span> <span class="op">/</span> dt_us  <span class="co"># Hz</span></span>
<span id="cb1-49"><a href="#cb1-49" tabindex="-1"></a>nyquist <span class="op">=</span> fs <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb1-50"><a href="#cb1-50" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sampling frequency: </span><span class="sc">{</span>fs<span class="op">/</span><span class="fl">1e6</span><span class="sc">:.2f}</span><span class="ss"> MHz, Nyquist: </span><span class="sc">{</span>nyquist<span class="op">/</span><span class="fl">1e6</span><span class="sc">:.2f}</span><span class="ss"> MHz"</span>)</span>
<span id="cb1-51"><a href="#cb1-51" tabindex="-1"></a></span>
<span id="cb1-52"><a href="#cb1-52" tabindex="-1"></a><span class="co"># --- Dynamically determine bandpass range ---</span></span>
<span id="cb1-53"><a href="#cb1-53" tabindex="-1"></a>lowcut <span class="op">=</span> <span class="fl">0.05</span> <span class="op">*</span> nyquist   <span class="co"># 5% of Nyquist</span></span>
<span id="cb1-54"><a href="#cb1-54" tabindex="-1"></a>highcut <span class="op">=</span> <span class="fl">0.95</span> <span class="op">*</span> nyquist  <span class="co"># 95% of Nyquist</span></span>
<span id="cb1-55"><a href="#cb1-55" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Applying bandpass filter: </span><span class="sc">{</span>lowcut<span class="op">/</span><span class="fl">1e6</span><span class="sc">:.2f}</span><span class="ss">–</span><span class="sc">{</span>highcut<span class="op">/</span><span class="fl">1e6</span><span class="sc">:.2f}</span><span class="ss"> MHz"</span>)</span>
<span id="cb1-56"><a href="#cb1-56" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" tabindex="-1"></a><span class="co"># --- Apply bandpass filter ---</span></span>
<span id="cb1-58"><a href="#cb1-58" tabindex="-1"></a>filtered_data <span class="op">=</span> bandpass_filter(data, lowcut, highcut, fs)</span>
<span id="cb1-59"><a href="#cb1-59" tabindex="-1"></a></span>
<span id="cb1-60"><a href="#cb1-60" tabindex="-1"></a><span class="co"># --- Plot before and after ---</span></span>
<span id="cb1-61"><a href="#cb1-61" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">6</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-62"><a href="#cb1-62" tabindex="-1"></a></span>
<span id="cb1-63"><a href="#cb1-63" tabindex="-1"></a>axs[<span class="dv">0</span>].imshow(data, cmap<span class="op">=</span><span class="st">"gray"</span>, aspect<span class="op">=</span><span class="st">"auto"</span>, origin<span class="op">=</span><span class="st">"upper"</span>)</span>
<span id="cb1-64"><a href="#cb1-64" tabindex="-1"></a>axs[<span class="dv">0</span>].set_title(<span class="st">"Original GPR Data"</span>)</span>
<span id="cb1-65"><a href="#cb1-65" tabindex="-1"></a>axs[<span class="dv">0</span>].set_xlabel(<span class="st">"Trace"</span>)</span>
<span id="cb1-66"><a href="#cb1-66" tabindex="-1"></a>axs[<span class="dv">0</span>].set_ylabel(<span class="st">"Sample"</span>)</span>
<span id="cb1-67"><a href="#cb1-67" tabindex="-1"></a></span>
<span id="cb1-68"><a href="#cb1-68" tabindex="-1"></a>axs[<span class="dv">1</span>].imshow(filtered_data, cmap<span class="op">=</span><span class="st">"gray"</span>, aspect<span class="op">=</span><span class="st">"auto"</span>, origin<span class="op">=</span><span class="st">"upper"</span>)</span>
<span id="cb1-69"><a href="#cb1-69" tabindex="-1"></a>axs[<span class="dv">1</span>].set_title(<span class="ss">f"Bandpass Filtered GPR</span><span class="ch">\n</span><span class="ss">(</span><span class="sc">{</span>lowcut<span class="op">/</span><span class="fl">1e6</span><span class="sc">:.1f}</span><span class="ss">–</span><span class="sc">{</span>highcut<span class="op">/</span><span class="fl">1e6</span><span class="sc">:.1f}</span><span class="ss"> MHz)"</span>)</span>
<span id="cb1-70"><a href="#cb1-70" tabindex="-1"></a>axs[<span class="dv">1</span>].set_xlabel(<span class="st">"Trace"</span>)</span>
<span id="cb1-71"><a href="#cb1-71" tabindex="-1"></a></span>
<span id="cb1-72"><a href="#cb1-72" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb1-73"><a href="#cb1-73" tabindex="-1"></a>plt.show()</span>
<span id="cb1-74"><a href="#cb1-74" tabindex="-1"></a></span>
<span id="cb1-75"><a href="#cb1-75" tabindex="-1"></a><span class="co"># --- Plot Frequency Spectra ---</span></span>
<span id="cb1-76"><a href="#cb1-76" tabindex="-1"></a>middle_trace_idx <span class="op">=</span> n_traces <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb1-77"><a href="#cb1-77" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb1-78"><a href="#cb1-78" tabindex="-1"></a>plot_frequency_spectrum(data[:, middle_trace_idx], fs, title<span class="op">=</span><span class="st">"Before Filter"</span>)</span>
<span id="cb1-79"><a href="#cb1-79" tabindex="-1"></a>plot_frequency_spectrum(filtered_data[:, middle_trace_idx], fs, title<span class="op">=</span><span class="st">"After Filter"</span>)</span>
<span id="cb1-80"><a href="#cb1-80" tabindex="-1"></a>plt.title(<span class="st">"Frequency Spectrum of Middle Trace"</span>)</span>
<span id="cb1-81"><a href="#cb1-81" tabindex="-1"></a>plt.legend()</span>
<span id="cb1-82"><a href="#cb1-82" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb1-83"><a href="#cb1-83" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>Explanation</p>
<p>Design the filter The cutoffs are normalized by Nyquist to design a
fourth-order Butterworth bandpass. This shape is smooth in magnitude
and, with forward-backward application, zero-phase in the output.</p>
<p>Validate cutoffs The code checks that both cutoffs fall strictly
between zero and Nyquist. Invalid values raise a clear error.</p>
<p>Apply zero-phase filtering Each trace is filtered with filtfilt,
which runs the filter forward and backward to cancel phase shift while
doubling the effective order.</p>
<p>Compute sampling parameters The sample interval from the SEG Y binary
header gives fs in hertz and nyquist = fs/2. These determine the
allowable band.</p>
<p>Inspect results in time and frequency Side-by-side images show
structural changes after filtering. A frequency spectrum of a
representative trace quantifies which bands were attenuated or
retained.</p>
<p>Interpretation Suppressing very low and very high frequencies
clarifies reflections within the passband. If reflections weaken or look
distorted, the passband is too narrow; relax the cutoffs toward the
data’s dominant band.</p>
</section><section><h2 class="section-heading" id="example-2-comparing-multiple-passbands">Example 2 — Comparing Multiple Passbands<a class="anchor" aria-label="anchor" href="#example-2-comparing-multiple-passbands"></a>
</h2>
<hr class="half-width">
<p>It is often unclear which cutoff frequencies best enhance
reflections. In this example, we apply three different passbands and
compare their effects on both the radargrams and frequency spectra.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Define three passband settings as fractions of Nyquist</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>passbands <span class="op">=</span> [</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>    (<span class="fl">0.02</span> <span class="op">*</span> nyquist, <span class="fl">0.80</span> <span class="op">*</span> nyquist),  <span class="co"># wide band</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>    (<span class="fl">0.05</span> <span class="op">*</span> nyquist, <span class="fl">0.50</span> <span class="op">*</span> nyquist),  <span class="co"># medium band</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>    (<span class="fl">0.10</span> <span class="op">*</span> nyquist, <span class="fl">0.30</span> <span class="op">*</span> nyquist)   <span class="co"># narrow band</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>]</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">6</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="cf">for</span> i, (lowcut, highcut) <span class="kw">in</span> <span class="bu">enumerate</span>(passbands):</span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>    filtered <span class="op">=</span> bandpass_filter(data, lowcut, highcut, fs)</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a>    axs[i].imshow(filtered, cmap<span class="op">=</span><span class="st">"gray"</span>, aspect<span class="op">=</span><span class="st">"auto"</span>, origin<span class="op">=</span><span class="st">"upper"</span>)</span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>    axs[i].set_title(<span class="ss">f"</span><span class="sc">{</span>lowcut<span class="op">/</span><span class="fl">1e6</span><span class="sc">:.2f}</span><span class="ss">–</span><span class="sc">{</span>highcut<span class="op">/</span><span class="fl">1e6</span><span class="sc">:.2f}</span><span class="ss"> MHz"</span>)</span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a>    axs[i].set_xlabel(<span class="st">"Trace"</span>)</span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a>        axs[i].set_ylabel(<span class="st">"Sample"</span>)</span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a>plt.show()</span>
<span id="cb2-20"><a href="#cb2-20" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" tabindex="-1"></a><span class="co"># Plot spectra for the middle trace across all three passbands</span></span>
<span id="cb2-22"><a href="#cb2-22" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb2-23"><a href="#cb2-23" tabindex="-1"></a><span class="cf">for</span> (lowcut, highcut) <span class="kw">in</span> passbands:</span>
<span id="cb2-24"><a href="#cb2-24" tabindex="-1"></a>    filtered <span class="op">=</span> bandpass_filter(data, lowcut, highcut, fs)</span>
<span id="cb2-25"><a href="#cb2-25" tabindex="-1"></a>    plot_frequency_spectrum(filtered[:, middle_trace_idx], fs,</span>
<span id="cb2-26"><a href="#cb2-26" tabindex="-1"></a>                            title<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>lowcut<span class="op">/</span><span class="fl">1e6</span><span class="sc">:.2f}</span><span class="ss">–</span><span class="sc">{</span>highcut<span class="op">/</span><span class="fl">1e6</span><span class="sc">:.2f}</span><span class="ss"> MHz"</span>)</span>
<span id="cb2-27"><a href="#cb2-27" tabindex="-1"></a>plot_frequency_spectrum(data[:, middle_trace_idx], fs, title<span class="op">=</span><span class="st">"Unfiltered"</span>)</span>
<span id="cb2-28"><a href="#cb2-28" tabindex="-1"></a>plt.title(<span class="st">"Frequency Spectra for Different Passbands"</span>)</span>
<span id="cb2-29"><a href="#cb2-29" tabindex="-1"></a>plt.legend()</span>
<span id="cb2-30"><a href="#cb2-30" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb2-31"><a href="#cb2-31" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>Explanation</p>
<p>Wide passband keeps nearly all signal but lets noise through.</p>
<p>Medium passband balances suppression of noise with preservation of
reflections.</p>
<p>Narrow passband reduces noise strongly but can distort wavelets and
weaken hyperbolas.</p>
<p>Comparing spectra confirms which frequencies remain in each case.</p>
</section><section><h2 class="section-heading" id="example-3-filtering-individual-traces-for-qc">Example 3 — Filtering Individual Traces for QC<a class="anchor" aria-label="anchor" href="#example-3-filtering-individual-traces-for-qc"></a>
</h2>
<hr class="half-width">
<p>Before filtering the entire dataset, it is useful to test the filter
on a few representative traces. This example applies the same bandpass
to three traces and compares them with the originals.</p>
<pre><code># Select three traces across the profile
trace_indices = [n_traces // 4, n_traces // 2, 3 * n_traces // 4]

lowcut = 0.05 * nyquist
highcut = 0.95 * nyquist

plt.figure(figsize=(12, 8))

for i, idx in enumerate(trace_indices, 1):
    original = data[:, idx]
    filtered = bandpass_filter(data[:, [idx]], lowcut, highcut, fs).flatten()

    plt.subplot(3, 1, i)
    plt.plot(original, label="Original", alpha=0.6)
    plt.plot(filtered, label="Filtered", linestyle="--")
    plt.title(f"Trace {idx} before and after bandpass")
    plt.xlabel("Sample")
    plt.ylabel("Amplitude")
    if i == 1:
        plt.legend()

plt.tight_layout()
plt.show()
</code></pre>
<p>Explanation</p>
<p>Original vs filtered traces plotted directly help confirm that
filtering removes unwanted frequencies without destroying arrivals.</p>
<p>Students can visually check if the wavelet shape is preserved.</p>
<p>This is a simple quality-control step before applying the filter to
the full dataset.</p>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-Deconvolution"><p>Content from <a href="Deconvolution.html">Deconvolution</a></p>
<hr>
<p>Last updated on 2025-09-07 |

        <a href="https://github.com/Azinkarimzad/Imaging_the_unseen/edit/main/episodes/Deconvolution.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What is deconvolution in the context of GPR processing?<br>
</li>
<li>Why do recorded GPR signals differ from the true earth
response?<br>
</li>
<li>How does spectral deconvolution recover sharper reflections?<br>
</li>
<li>What is the role of the stabilization parameter in
deconvolution?<br>
</li>
<li>How can we evaluate the effect of deconvolution on traces and
sections?<br>
</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Define deconvolution and explain its purpose in GPR signal
processing.<br>
</li>
<li>Implement frequency-domain (spectral) deconvolution on individual
traces and full sections.<br>
</li>
<li>Assess the impact of stabilization on the recovered signal.<br>
</li>
<li>Compare radargrams before and after deconvolution to evaluate
reflector clarity.<br>
</li>
<li>Use single-trace examples to illustrate wavelet shortening.<br>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>GPR records are a convolution of the source wavelet and subsurface
reflectivity.<br>
</li>
<li>Deconvolution aims to remove the source wavelet, recovering a
spike-like reflectivity.<br>
</li>
<li>Spectral deconvolution divides the spectrum by its amplitude, with
stabilization to avoid noise blow-up.<br>
</li>
<li>Spiking deconvolution sharpens arrivals but requires careful
parameter tuning.<br>
</li>
<li>Stabilization controls the trade-off between resolution gain and
noise amplification.<br>
</li>
</ul>
</div>
</div>
</div>
<div class="introduction">
<p>Ground Penetrating Radar (GPR) does not record the true reflectivity
of the subsurface. Instead, each trace represents the
<strong>convolution</strong> of the antenna source wavelet with
reflections from interfaces in the ground. This convolution blurs the
reflectivity, producing wavelets rather than sharp spikes.</p>
<p><strong>Deconvolution</strong> is a signal processing step that
attempts to undo this effect by compressing the wavelet into something
closer to a spike. The goal is improved temporal resolution, so that
thin layers and closely spaced reflectors can be better
distinguished.</p>
<p>A common approach is <strong>spectral deconvolution</strong>. In the
frequency domain, the observed trace spectrum is divided by its
amplitude spectrum (with a small stabilization factor added to prevent
division by near-zero values). The phase is preserved. After inverse
Fourier transform, the resulting trace shows sharpened reflections.</p>
<p>The stabilization constant is critical: too small and noise
dominates; too large and resolution gains are lost. In practice,
deconvolution is applied trace-by-trace across the section and results
are compared to the original radargram to confirm improved clarity
without excessive noise.</p>
</div>
<section><h2 class="section-heading" id="example-1-spectral-deconvolution-on-a-2d-gpr-section">Example 1 — Spectral Deconvolution on a 2D GPR Section<a class="anchor" aria-label="anchor" href="#example-1-spectral-deconvolution-on-a-2d-gpr-section"></a>
</h2>
<hr class="half-width">
<p>The following code implements spectral deconvolution for each trace
of a SEG-Y GPR section and compares the radargram before and after
processing.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">from</span> obspy.io.segy.segy <span class="im">import</span> _read_segy</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">from</span> scipy.fft <span class="im">import</span> rfft, irfft, rfftfreq</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="kw">def</span> spectral_decon(trace, fs, stab<span class="op">=</span><span class="fl">0.01</span>):</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="co">    Apply frequency-domain (spectral) deconvolution to a trace.</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(trace)</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>    f <span class="op">=</span> rfftfreq(n, d<span class="op">=</span><span class="dv">1</span><span class="op">/</span>fs)</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>    spectrum <span class="op">=</span> rfft(trace)</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>    amp <span class="op">=</span> np.<span class="bu">abs</span>(spectrum)</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>    phase <span class="op">=</span> spectrum <span class="op">/</span> (amp <span class="op">+</span> <span class="fl">1e-12</span>)  <span class="co"># preserve phase</span></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>    <span class="co"># Invert amplitude spectrum with stabilization</span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>    inverse_amp <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (amp <span class="op">+</span> stab <span class="op">*</span> np.<span class="bu">max</span>(amp))</span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a>    decon_spectrum <span class="op">=</span> inverse_amp <span class="op">*</span> spectrum</span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a>    <span class="co"># Back to time domain</span></span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a>    decon_trace <span class="op">=</span> irfft(decon_spectrum, n<span class="op">=</span>n)</span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a>    <span class="cf">return</span> decon_trace</span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a><span class="co"># --- Load SEG-Y GPR data ---</span></span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a>segy_file <span class="op">=</span> <span class="st">"LINE01.sgy"</span></span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a>stream <span class="op">=</span> _read_segy(segy_file, headonly<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a><span class="co"># Build 2D data array [samples x traces]</span></span>
<span id="cb1-29"><a href="#cb1-29" tabindex="-1"></a>n_traces <span class="op">=</span> <span class="bu">len</span>(stream.traces)</span>
<span id="cb1-30"><a href="#cb1-30" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="bu">max</span>(<span class="bu">len</span>(tr.data) <span class="cf">for</span> tr <span class="kw">in</span> stream.traces)</span>
<span id="cb1-31"><a href="#cb1-31" tabindex="-1"></a>data <span class="op">=</span> np.zeros((n_samples, n_traces))</span>
<span id="cb1-32"><a href="#cb1-32" tabindex="-1"></a><span class="cf">for</span> i, tr <span class="kw">in</span> <span class="bu">enumerate</span>(stream.traces):</span>
<span id="cb1-33"><a href="#cb1-33" tabindex="-1"></a>    data[:<span class="bu">len</span>(tr.data), i] <span class="op">=</span> tr.data</span>
<span id="cb1-34"><a href="#cb1-34" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" tabindex="-1"></a><span class="co"># --- Sampling frequency ---</span></span>
<span id="cb1-36"><a href="#cb1-36" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb1-37"><a href="#cb1-37" tabindex="-1"></a>    dt_us <span class="op">=</span> stream.binary_file_header.sample_interval_in_microseconds</span>
<span id="cb1-38"><a href="#cb1-38" tabindex="-1"></a>    <span class="cf">if</span> dt_us <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> dt_us <span class="op">&gt;</span> <span class="dv">10</span>:</span>
<span id="cb1-39"><a href="#cb1-39" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Header sample interval </span><span class="sc">{</span>dt_us<span class="sc">}</span><span class="ss"> µs seems invalid. Overriding to 0.5 µs."</span>)</span>
<span id="cb1-40"><a href="#cb1-40" tabindex="-1"></a>        dt_us <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb1-41"><a href="#cb1-41" tabindex="-1"></a><span class="cf">except</span>:</span>
<span id="cb1-42"><a href="#cb1-42" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Sample interval not found. Using default of 0.5 µs."</span>)</span>
<span id="cb1-43"><a href="#cb1-43" tabindex="-1"></a>    dt_us <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb1-44"><a href="#cb1-44" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" tabindex="-1"></a>fs <span class="op">=</span> <span class="fl">1e6</span> <span class="op">/</span> dt_us</span>
<span id="cb1-46"><a href="#cb1-46" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sampling rate: </span><span class="sc">{</span>fs<span class="op">/</span><span class="fl">1e6</span><span class="sc">:.2f}</span><span class="ss"> MHz"</span>)</span>
<span id="cb1-47"><a href="#cb1-47" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" tabindex="-1"></a><span class="co"># --- Apply spectral deconvolution ---</span></span>
<span id="cb1-49"><a href="#cb1-49" tabindex="-1"></a>decon_data <span class="op">=</span> np.zeros_like(data)</span>
<span id="cb1-50"><a href="#cb1-50" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_traces):</span>
<span id="cb1-51"><a href="#cb1-51" tabindex="-1"></a>    decon_data[:, i] <span class="op">=</span> spectral_decon(data[:, i], fs<span class="op">=</span>fs, stab<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb1-52"><a href="#cb1-52" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" tabindex="-1"></a><span class="co"># --- Plot comparison ---</span></span>
<span id="cb1-54"><a href="#cb1-54" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">6</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-55"><a href="#cb1-55" tabindex="-1"></a>axs[<span class="dv">0</span>].imshow(data, cmap<span class="op">=</span><span class="st">"gray"</span>, aspect<span class="op">=</span><span class="st">"auto"</span>, origin<span class="op">=</span><span class="st">"upper"</span>)</span>
<span id="cb1-56"><a href="#cb1-56" tabindex="-1"></a>axs[<span class="dv">0</span>].set_title(<span class="st">"Original GPR Data"</span>)</span>
<span id="cb1-57"><a href="#cb1-57" tabindex="-1"></a>axs[<span class="dv">0</span>].set_xlabel(<span class="st">"Trace"</span>)</span>
<span id="cb1-58"><a href="#cb1-58" tabindex="-1"></a>axs[<span class="dv">0</span>].set_ylabel(<span class="st">"Sample"</span>)</span>
<span id="cb1-59"><a href="#cb1-59" tabindex="-1"></a></span>
<span id="cb1-60"><a href="#cb1-60" tabindex="-1"></a>axs[<span class="dv">1</span>].imshow(decon_data, cmap<span class="op">=</span><span class="st">"gray"</span>, aspect<span class="op">=</span><span class="st">"auto"</span>, origin<span class="op">=</span><span class="st">"upper"</span>)</span>
<span id="cb1-61"><a href="#cb1-61" tabindex="-1"></a>axs[<span class="dv">1</span>].set_title(<span class="st">"Spectral Deconvolved GPR Data"</span>)</span>
<span id="cb1-62"><a href="#cb1-62" tabindex="-1"></a>axs[<span class="dv">1</span>].set_xlabel(<span class="st">"Trace"</span>)</span>
<span id="cb1-63"><a href="#cb1-63" tabindex="-1"></a></span>
<span id="cb1-64"><a href="#cb1-64" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb1-65"><a href="#cb1-65" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>Explanation:</p>
<p>Fourier transform each trace → separate amplitude and phase.</p>
<p>Invert amplitude spectrum, with stabilization constant to prevent
division by zero.</p>
<p>Recombine with phase and inverse transform → sharpened trace.</p>
<p>Apply across all traces to produce deconvolved section.</p>
<p>Compare radargrams before and after → reflections appear narrower and
better resolved.</p>
</section><section><h2 class="section-heading" id="example-2-spiking-deconvolution-on-a-single-trace">Example 2 — Spiking Deconvolution on a Single Trace<a class="anchor" aria-label="anchor" href="#example-2-spiking-deconvolution-on-a-single-trace"></a>
</h2>
<hr class="half-width">
<p>Spiking deconvolution uses the autocorrelation of a trace to estimate
its wavelet and design a filter that compresses it into a spike.</p>
<pre><code>from scipy.linalg import toeplitz, solve_toeplitz

def spiking_decon(trace, stab=0.1, filter_length=30):
    """
    Spiking deconvolution using Wiener filter design.
    """
    # Autocorrelation
    autocorr = np.correlate(trace, trace, mode="full")
    autocorr = autocorr[autocorr.size // 2:]

    # Toeplitz system
    R = toeplitz(autocorr[:filter_length])
    r = np.zeros(filter_length)
    r[0] = 1.0  # desired spike

    # Stabilization
    R += stab * np.eye(filter_length)

    # Solve Wiener-Hopf equations
    f = np.linalg.solve(R, autocorr[:filter_length])
    decon = np.convolve(trace, f, mode="same")
    return decon

# Apply to one representative trace
trace_idx = n_traces // 2
original_trace = data[:, trace_idx]
decon_trace = spiking_decon(original_trace, stab=0.1, filter_length=30)

plt.figure(figsize=(10, 4))
plt.plot(original_trace, label="Original", alpha=0.7)
plt.plot(decon_trace, label="Spiking Deconvolved", linestyle="--")
plt.title(f"Trace {trace_idx} before and after Spiking Deconvolution")
plt.xlabel("Sample")
plt.ylabel("Amplitude")
plt.legend()
plt.grid(True)
plt.show()
</code></pre>
<p>Explanation</p>
<p>Estimate wavelet from autocorrelation of the trace.</p>
<p>Solve Wiener equations to design filter that compresses wavelet into
a spike.</p>
<p>Convolve filter with trace → spike-like reflectivity series.</p>
<p>Useful for single traces or small windows where spectral method is
unstable.</p>
</section><section><h2 class="section-heading" id="example-3-effect-of-stabilization-on-spectral-deconvolution">Example 3 — Effect of Stabilization on Spectral Deconvolution<a class="anchor" aria-label="anchor" href="#example-3-effect-of-stabilization-on-spectral-deconvolution"></a>
</h2>
<hr class="half-width">
<p>The stabilization constant (stab) controls the balance between
resolution gain and noise. This example applies different values and
compares results.</p>
<pre><code>stab_values = [0.01, 0.1, 1.0]

fig, axs = plt.subplots(1, 3, figsize=(18, 6), sharey=True)

for i, stab in enumerate(stab_values):
    decon_data_test = np.zeros_like(data)
    for j in range(n_traces):
        decon_data_test[:, j] = spectral_decon(data[:, j], fs=fs, stab=stab)
    axs[i].imshow(decon_data_test, cmap="gray", aspect="auto", origin="upper")
    axs[i].set_title(f"Spectral Deconvolution\nstab={stab}")
    axs[i].set_xlabel("Trace")
    if i == 0:
        axs[i].set_ylabel("Sample")

plt.tight_layout()
plt.show()
</code></pre>
<p>Explanation</p>
<p>Small stab (0.01): strong wavelet compression but high noise
amplification.</p>
<p>Moderate stab (0.1): balanced improvement; often practical.</p>
<p>Large stab (1.0): stable but reflections less sharpened.</p>
<p>Students can see the trade-off and understand why stabilization is
critical.</p>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-Wrap-up and Discussion"><p>Content from <a href="Wrap-up%20and%20Discussion.html">Wrap-up and Discussion</a></p>
<hr>
<p>Last updated on 2025-09-07 |

        <a href="https://github.com/Azinkarimzad/Imaging_the_unseen/edit/main/episodes/Wrap-up%20and%20Discussion.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are the main processing steps applied to GPR data in this
course?<br>
</li>
<li>How do these steps improve interpretability of radargrams?<br>
</li>
<li>Which processing choices require the most careful parameter
selection?<br>
</li>
<li>How can Python be used flexibly to test and evaluate different
workflows?<br>
</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Summarize the core processing steps learned: visualization, AGC,
background removal, time-zero correction, bandpass filtering, and
deconvolution.<br>
</li>
<li>Reflect on how each step alters the data and what geophysical
problem it addresses.<br>
</li>
<li>Encourage critical evaluation of parameters and their impact on
results.<br>
</li>
<li>Prepare learners to design their own GPR processing workflows for
new datasets.<br>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>GPR traces are raw recordings that must be processed for reliable
interpretation.<br>
</li>
<li>Each processing step—AGC, background removal, time-zero correction,
filtering, deconvolution—has a clear physical motivation.<br>
</li>
<li>Parameters (e.g., filter cutoffs, stabilization constants) control
the trade-off between resolution and noise.<br>
</li>
<li>No single workflow is universal; effective GPR interpretation
requires testing, visual inspection, and critical judgment.<br>
</li>
<li>Python offers a transparent environment for experimenting with and
combining different methods.<br>
</li>
</ul>
</div>
</div>
</div></section>
</div>
    </main>
</div>
<!-- END  : inst/pkgdown/templates/content-extra.html -->

      </div>
<!--/div.row-->
      		<footer class="row footer mx-md-3"><hr>
<div class="col-md-6">
        <p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>

        <a href="https://github.com/Azinkarimzad/Imaging_the_unseen/edit/main/README.md" class="external-link">Edit on GitHub</a>

	
        | <a href="https://github.com/Azinkarimzad/Imaging_the_unseen/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/Azinkarimzad/Imaging_the_unseen/" class="external-link">Source</a></p>
				<p><a href="https://github.com/Azinkarimzad/Imaging_the_unseen/blob/main/CITATION.cff" class="external-link">Cite</a> | <a href="mailto:team@carpentries.org">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">

        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>

        <p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">CC-BY 4.0</a> by <a href="https://carpentries.org/" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.17.1" class="external-link">sandpaper (0.17.1)</a>, <a href="https://github.com/carpentries/pegboard/tree/0.7.9" class="external-link">pegboard (0.7.9)</a>, and <a href="https://github.com/carpentries/varnish/tree/1.0.7" class="external-link">varnish (1.0.7)</a></p>
			</div>
		</footer>
</div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "LearningResource",
  "@id": "https://Azinkarimzad.github.io/Imaging_the_unseen/aio.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/LearningResource/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "software, data, lesson, The Carpentries",
  "name": "All in One View",
  "creativeWorkStatus": "active",
  "url": "https://Azinkarimzad.github.io/Imaging_the_unseen/aio.html",
  "identifier": "https://Azinkarimzad.github.io/Imaging_the_unseen/aio.html",
  "dateCreated": "2025-09-07",
  "dateModified": "2025-09-07",
  "datePublished": "2025-09-07"
}

  </script><script>
		feather.replace();
	</script>
</body>
</html><!-- END:   inst/pkgdown/templates/layout.html-->

